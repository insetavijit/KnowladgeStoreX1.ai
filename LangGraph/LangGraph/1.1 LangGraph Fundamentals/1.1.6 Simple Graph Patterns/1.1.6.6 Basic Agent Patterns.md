Below is a **similar-styled, interview-focused table** for **[[1.1.6.6 Basic Agent Patterns]]**, covering LLM-based reasoning and tool interaction.

|**Section**|**Interview Learning Goals**|**Key Technical Details to Study**|**One-Line Recall**|
|---|---|---|---|
|**Basic Agent Patterns Overview**|Explain agents as systems combining LLM reasoning with tool execution.**Agent patterns; LLM agents; reasoning loops; tool use; autonomous decision making; agent architecture; classic pattern.**Agent patterns combine LLM reasoning, decision making, and tool execution in iterative loops; foundation of many systems.|
|**[[ReAct Loop Pattern]]**|Describe the ReAct (Reasoning + Acting) pattern.**ReAct; reasoning; acting; thought-action-observation cycle; iterative loop; decision cycle; classic agent pattern.**ReAct pattern: LLM thinks about problem, chooses action/tool, executes tool, observes result, repeats until done.|
|**[[Agent Components]]**|Show the main components of an agent.**Agent components; LLM node; tool nodes; router; state; thinking; action; observation; architecture; components.**Agent components: LLM node (reasoning), tool nodes (execution), router (decision), state (context/history/results).|
|**[[LLM Node for Reasoning]]**|Explain the LLM node that does the thinking.**LLM node; reasoning; decision making; plan; next action; LLM call; prompt engineering; thought generation; reasoning component.**LLM node: takes state, generates reasoning and action choice; prompt instructs format for action specification.**
|**[[Tool Nodes for Execution]]**|Describe tool nodes that perform actions.**Tool nodes; external tools; API calls; function execution; action execution; side effects; tool definition; execution component.**Tool nodes: defined for each available tool; receive action request, execute tool, return observation to state.**
|**[[Router for Action Selection]]**|Show the conditional router that directs to appropriate tool.**Router; conditional routing; action parsing; tool selection; routing function; decision logic; routing component; tool dispatcher.**Router: parses LLM action choice, routes to appropriate tool node; handles "finish" action to exit loop.**
|**[[Tool Availability Management]]**|Explain specifying available tools to agent.**Available tools; tool definition; tool schema; tool description; tool list; communicating capabilities; tool specification; capability definition.**Communicate available tools to LLM: tool descriptions, parameters, expected outputs; enables informed tool selection.**
|**[[Tool Calling/Function Calling]]**|Describe modern LLM tool calling support.**Tool calling; function calling; structured output; tool schema; native support; XML/JSON; function selection; native capability.**Modern LLMs support tool/function calling: native structured tool invocation; superior to text-based action parsing.**
|**[[Observation as Feedback]]**|Explain tool results become observations for next iteration.**Observation; feedback; result feedback; observation state; learning; next iteration; context for next step; iterative improvement.**Tool results become observations added to state; LLM sees results; uses for next reasoning iteration; closes loop.**
|**[[Agent Termination Conditions]]**|Show how agents decide when done.**Termination; finish action; goal achievement; max iterations; stopping; end condition; loop exit; termination logic.**Agents terminate when: LLM chooses finish action, max iterations reached, or special termination condition met.**
|**[[Memory in Agent Patterns]]**|Describe maintaining conversation/action history.**Memory; history; conversation history; action history; context accumulation; state accumulation; context window; context management.**Store conversation history and action results in state; enables LLM to see context and progress; maintains continuity.**
|**[[Agent Error Handling]]**|Explain handling tool failures within agents.**Error handling; tool failures; exception handling; graceful failure; error observation; error recovery; robust agents; resilience.**Handle tool errors: catch exceptions, log errors, include error in observations; agent learns from failures and retries differently.**
|**[[Single-Tool vs Multi-Tool Agents]]**|Describe agents with one tool vs multiple tools.**Tool scope; single tool; multiple tools; complexity; routing; tool selection; simplicity vs flexibility; design choice.**Simple agent: one tool; agent focuses on when/how to use it; complex agent: multiple tools; routing complexity increases.**
|**[[Agent Prompt Engineering]]**|Explain crafting prompts to guide agent behavior.**Prompt engineering; instruction clarity; behavior guidance; system prompt; reasoning guidance; action guidance; instruction quality.**Well-engineered prompts: clear instructions, examples, format specs; guide agent to correct behavior and thinking.**
|**[[Testing Agent Patterns]]**|Describe testing agents comprehensively.**Agent testing; behavior testing; tool integration testing; reasoning verification; action correctness; test strategy; thorough testing.**Test agents: verify correct tool selection, action execution, proper termination; test edge cases and failures.**
|**[[Building on Agent Patterns]]**|Show extending basic agents with advanced features.**Extensions; advanced agents; memory systems; planning, tool composition; sophistication; building blocks; enhancement; growth path.**Basic agent pattern is foundation; extend with memory, planning, tool composition, verification; build sophisticated systems.|

Next, we'll cover **[[1.1.6.7 Single-Node Graphs]]** for minimal workflows.
