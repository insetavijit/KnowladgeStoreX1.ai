Below is a **similar-styled, interview-focused table** for **[[1.1.5.5 Execution Modes]]**, covering different ways to run graphs.

|**Section**|**Interview Learning Goals**|**Key Technical Details to Study**|**One-Line Recall**|
|---|---|---|---|
|**Execution Modes Overview**|Explain the different modes for executing graphs.**Multiple execution modes; single run; streaming; batch; interactive; selection criteria; use case matching; execution model choice.**Graphs can be executed in multiple modes: single synchronous run, streaming, batch, or interactive patterns.|
|**[[Single Invocation Mode]]**|Describe executing a graph once and waiting for completion.**Single execution; one input; one output; blocking; atomic; simple; batch processing; one-shot execution model.**invoke() mode: execute once, block until done, return final state; simplest execution model.|
|**[[Streaming Mode]]**|Explain executing with incremental intermediate output.**Streaming execution; progressive results; real-time feedback; monitoring; iteration; event-driven; observable execution.**stream() mode: execute and yield intermediate results; observe execution progress incrementally.|
|**[[Batch Processing Mode]]**|Show executing multiple workflows in sequence or parallel.**Batch execution; multiple inputs; sequential or parallel; throughput; efficiency; bulk processing; multiple workflows.**Batch: invoke() multiple times with different inputs; either sequentially or in parallel for throughput.|
|**[[Interactive Mode]]**|Describe workflows with user input during execution.**Human-in-the-loop; interrupts; user input points; pauses; manual control; interactive workflows; human oversight; control flow.**Interactive: pause execution for user input/approval; resume after human decision; human-in-the-loop pattern.|
|**[[Async Execution Mode]]**|Explain non-blocking asynchronous execution.**Async methods; ainvoke(); astream(); non-blocking; concurrent; event loop; async/await; concurrency; efficiency.**ainvoke() and astream() enable async execution; non-blocking for concurrent graph runs; async/await compatible.|
|**[[One-Shot Single Run]]**|Show using invoke() for simple one-time execution.**Single workflow; complete execution; final result; simplicity; clarity; typical usage; most common; straightforward; common pattern.**One-shot: invoke() once to run a complete workflow from start to finish; return final state.|
|**[[Continuous/Loop Execution]]**|Describe repeatedly running graphs for continuous processing.**Repeated execution; loop execution; continuous processing; streaming input; never-ending workflows; monitoring; continuous operation.**Loop: repeatedly invoke() or stream() graphs for continuous processing of input streams.|
|**[[Event-Driven Execution]]**|Explain triggering graph execution based on events.**Event triggers; event-driven; stimulus-response; external events; reactive; event loop; event model; reactive programming.**Execute graphs in response to events: API calls, webhook events, queue messages, timers, etc.|
|**[[Scheduled Execution]]**|Describe running graphs on a schedule or timer.**Scheduled runs; periodic execution; timer-based; cron-like; batch jobs; scheduled processing; time-based triggers; recurring patterns.**Schedule: execute graphs periodically (hourly, daily) for scheduled tasks or batch processing.|
|**[[Concurrent/Parallel Execution]]**|Show running multiple graph instances concurrently.**Parallel execution; concurrent instances; multiple threads; async concurrency; throughput; scalability; parallel processing; efficiency.**Run multiple graph instances in parallel: via threads, async, or multiprocessing for concurrent processing.|
|**[[Sequential Execution]]**|Explain running graphs one after another in sequence.**Sequential runs; ordered execution; one at a time; serialized; consistency; determinism; simplicity; ordered processing.**Execute graphs sequentially: finish one before starting next; simpler but slower than concurrent execution.|
|**[[Mode Selection Criteria]]**|Describe how to choose the right execution mode.**Use case matching; latency requirements; throughput needs; interactivity; observability; simplicity; performance; requirements driven.**Choose mode based on: output latency, interactivity needs, monitoring requirements, throughput targets, simplicity.|
|**[[Mixed Mode Patterns]]**|Show combining multiple modes in the same application.**Multiple modes; hybrid approaches; conditional selection; adaptive; flexible patterns; appropriate usage; pattern mixing.**Some applications use different modes for different workflows: streaming for monitoring, invoke() for batch jobs.|
|**[[Performance Implications]]**|Explain performance characteristics of different modes.**invoke(): simple, batch; stream(): incremental overhead; async: concurrent; batch: throughput; selection impact; performance factors.**Mode choice affects latency, throughput, concurrency; select based on performance requirements.|
|**[[Debugging Different Modes]]**|Describe debugging techniques for each execution mode.**invoke() debugging: simple; stream() debugging: observe events; async debugging: async tools; mode-specific techniques; debugging strategy.**Debug invoke() with logging; stream() by inspecting events; async with async debuggers.|

If you want, I can next create similar tables for **[[1.1.5.6 Checkpointing in Execution]]** or **[[1.1.5.7 Graph Validation]]** to continue this modes track.
