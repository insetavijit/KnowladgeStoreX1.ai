Below is a **similar-styled, interview-focused table** for **[[1.1.3.11 Common Node Patterns]]**, describing practical node designs used frequently.

|**Section**|**Interview Learning Goals**|**Key Technical Details to Study**|**One-Line Recall**|
|---|---|---|---|
|**Common Node Patterns Overview**|Explain recurring node design patterns found in production LangGraph workflows.**Proven patterns; real-world examples; design templates; reusable architectures; best practices; learning from experience.**Common node patterns are battle-tested designs extracted from successful LangGraph implementations.|
|**[[LLM Call Node Pattern]]**|Describe the standard pattern for calling LLMs in a node.**LLM invocation; prompt construction; response handling; parsing; error handling; message integration; ubiquitous pattern.**LLM nodes invoke language models, format responses, and update state with results and reasoning.|
|**[[Tool Execution Node Pattern]]**|Show nodes that invoke tools or function calling APIs.**Tool invocation; function calling; argument binding; result handling; error catching; output parsing; common pattern.**Tool nodes execute external functions, handle results, and return success/failure states.|
|**[[Decision/Condition Node Pattern]]**|Explain nodes that check conditions and determine routing.**State inspection; boolean logic; condition evaluation; routing decision; simple checks; guards; common infrastructure.**Decision nodes check state conditions and return indicators used in conditional edges.|
|**[[Data Transformation Node]]**|Show nodes that reshape or transform data structure.**Data mapping; field transformation; parsing; serialization; normalization; format conversion; common utilities.**Transformation nodes reshape data: parse strings, convert formats, extract fields, normalize structures.|
|**[[Validation Node Pattern]]**|Describe nodes that validate data or check constraints.**Validation logic; constraint checks; error states; validation results; pass/fail indication; common infrastructure; reliability.**Validation nodes check data validity, constraints, and business rules; return validation state.|
|**[[Message Assembly Pattern]]**|Show nodes that construct messages for conversation contexts.**Message creation; role assignment; content formatting; metadata; history assembly; message list building; common pattern.**Message nodes create properly formatted messages for conversation history and LLM consumption.|
|**[[Result Aggregation Pattern]]**|Describe nodes that accumulate and combine results from previous steps.**List accumulation; result collection; combination; deduplication; filtering; aggregation logic; common synthesis pattern.**Aggregation nodes collect and combine results from multiple sources into unified state.|
|**[[Error Handling & Recovery Node]]**|Show nodes designed to handle failures and initiate recovery.**Error detection; recovery logic; fallback strategies; retry initiation; error state updates; resilience patterns; error response.**Error nodes detect failures and initiate recovery (retries, alternatives, graceful degradation).|
|**[[Branching/Routing Logic Node**|Explain nodes that analyze state and decide execution paths.**Routing logic; path selection; state inspection; decision function; multiple outcomes; complex routing; orchestration.**Routing nodes analyze state and determine which next node or path to execute.|
|**[[State Checkpoint/Logging Node]]**|Show nodes that save state snapshots or log important information.**Logging; checkpointing; state serialization; audit trails; debugging snapshots; monitoring; introspection.**Logging nodes record state snapshots at key points for debugging, auditing, and observability.|
|**[[Human-in-the-Loop Node**|Describe nodes that pause for human input or approval.**Interrupt points; user input collection; approval gates; human feedback; interactive workflows; manual oversight; control points.**Human-in-the-loop nodes pause execution and collect user decisions or approvals.|
|**[[Retry/Resilience Node Pattern]]**|Show nodes implementing retry logic with backoff.**Retry attempts; backoff strategy; transient error handling; max retries; failure recovery; resilience; robustness pattern.**Retry nodes implement backoff logic to safely reattempt flaky operations.|
|**[[Filtering & Pruning Pattern]]**|Describe nodes that filter data or narrow down options.**Filter logic; condition-based selection; subset creation; pruning; relevance ranking; cleanup; data reduction pattern.**Filter nodes remove irrelevant items or narrow options based on criteria.|
|**[[Streaming/Output Node Pattern]]**|Show nodes that format and emit final results.**Result formatting; output preparation; streaming interface; presentation; final state assembly; output patterns; completion.**Output nodes format results for presentation and emit final workflow outputs.|
|**[[Context/Memory Update Node**|Explain nodes that maintain and update working memory or context.**Memory updates; state enrichment; context accumulation; metadata tracking; reference storage; memory management; context patterns.**Memory nodes update accumulated context, add metadata, and maintain working memory.|
|**[[Pattern Composition & Combinations]]**|Show how patterns combine to create complex node sequences.**Pattern stacking; sequence combinations; common workflows; familiar architectures; composability; reuse; known patterns.**Combine patterns in sequences: LLM -> Parse -> Validate -> Aggregate -> Output is a common workflow.|

If you want, I can next create similar tables for **[[1.1.3.12 Node Best Practices & Pitfalls]]** to complete this pattern track.
