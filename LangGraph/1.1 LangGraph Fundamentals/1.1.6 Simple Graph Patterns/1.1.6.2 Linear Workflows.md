Below is a **similar-styled, interview-focused table** for **[[1.1.6.2 Linear Workflows]]**, covering sequential execution chains.

|**Section**|**Interview Learning Goals**|**Key Technical Details to Study**|**One-Line Recall**|
|---|---|---|---|
|**Linear Workflows Overview**|Explain sequential node execution without branching.**Linear pattern; sequential execution; node chains; simple flows; straightforward logic; step-by-step; simple pattern; basic structure.**Linear workflows execute nodes sequentially: node1 → node2 → node3 without branching or looping.|
|**[[Basic Linear Structure]]**|Show a simple chain of three or four nodes.**Graph structure; node sequence; edge structure; simple chain; sequential edges; one-way flow; basic example.**Simple structure: add nodes; connect with edges in sequence; each node executes after previous completes.|
|**[[When to Use Linear Patterns]]**|Describe problems suited for linear workflows.**Use cases; sequential problems; pipeline; data pipeline; processing pipeline; applicability; problem fit; suitable problems.**Use linear patterns for: data pipelines, processing sequences, step-by-step transformations, sequential logic flows.|
|**[[Sequential State Updates]]**|Show how state flows through linear workflows.**State flow; state updates; each node modifies state; progression; state evolution; state path; transformation sequence.**Each node receives state, processes, returns updated state; next node receives modified state; continues chain.|
|**[[Error Handling in Linear Workflows]]**|Describe handling errors in sequential nodes.**Error handling; try/except; error propagation; graceful failure; recovery; error tolerance; fault handling; resilience.**Handle errors in nodes: catch exceptions, log errors, update state, optionally continue or fail gracefully.**
|**[[Input Preparation in Linear Workflows]]**|Explain preparing initial state for linear workflows.**Initial state; input setup; state initialization; data preparation; setup; bootstrapping; initial values; state schema matching.**Prepare initial state that satisfies schema; provide input_dict to invoke(); state flows through chain.**
|**[[Output Extraction from Linear Workflows]]**|Show extracting final results from linear workflows.**Final state; result extraction; output; completion; result retrieval; final result; output structure; result format.**Invoke returns final state; extract relevant fields; use results downstream or return to user.|
|**[[Linear Workflow Performance]]**|Describe performance characteristics of linear workflows.**Performance; sequential bottleneck; latency; throughput; critical path; efficiency; execution time; slowest node.**Linear workflows: total time = sum of node times; slowest node is bottleneck; no parallelism possible.|
|**[[Optimizing Linear Workflows]]**|Show optimization strategies for sequential chains.**Optimization; node merging; eliminating bottlenecks; efficiency improvement; speed; latency reduction; optimization techniques.**Optimize: merge fine-grained nodes, optimize slowest nodes, reduce state size; avoid unnecessary computations.|
|**[[Linear Workflow State Design]]**|Explain state schema for linear workflows.**State schema; TypedDict; field design; required fields; field types; minimal state; schema design; efficiency.**Design state schema with fields needed by all nodes; avoid bloat; use Optional for truly optional fields.|
|**[[Testing Linear Workflows]]**|Describe testing strategies for linear patterns.**Unit testing; integration testing; test cases; verification; correctness; test coverage; test strategy; quality assurance.**Test: verify each node works independently, test state flow through chain, verify final output correctness.**
|**[[Composition with Other Patterns]]**|Show combining linear patterns with other patterns.**Composition; combination; nesting; complex patterns; building blocks; hybrid patterns; mixture; pattern combination.**Use linear workflows as building blocks within larger patterns: agent loops, branching, retries at higher level.**
|**[[Idempotency in Linear Workflows]]**|Explain designing nodes to be safely replayable.**Idempotency; replayability; checkpointing recovery; safety; determinism; restart safety; repeatability; safe resumption.**Design linear nodes to be idempotent: safe to re-execute from checkpoint; enables robust restart capability.|
|**[[Streaming Results from Linear Workflows]]**|Describe progressively returning results using stream().**Streaming; progressive results; stream(); partial results; incremental output; responsiveness; UX improvement; early results.**Use stream() to progressively return state at each node; enables early partial results; improves perceived latency.|
|**[[Documentation for Linear Workflows]]**|Show documenting linear workflow purpose and structure.**Documentation; comments; docstrings; design rationale; clarity; communication; understanding; documentation value.**Document purpose, node sequence, expected inputs/outputs; explain state transformations clearly for team understanding.|

Next, we'll cover **[[1.1.6.3 Branching Patterns]]** for conditional routing.
