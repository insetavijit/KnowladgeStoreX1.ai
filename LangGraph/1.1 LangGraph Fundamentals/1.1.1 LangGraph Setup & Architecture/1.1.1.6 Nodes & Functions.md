Below is a **similar-styled, interview-focused table** for **[[1.1.1.6 Nodes & Functions]]**, aligned with your prior learning structure.

|**Section**|**Interview Learning Goals**|**Key Technical Details to Study**|**One-Line Recall**|
|---|---|---|---|
|**Nodes & Functions**|Explain how nodes encapsulate computation as callable functions in LangGraph.|Function signature; input/output types; state access; node registration; callables vs methods; naming.|Nodes encapsulate individual steps in the agent.|
|**[[Node Definition Basics]]**|Write a simple node function that reads state and returns updates.|async vs sync functions; parameter patterns; return types; state access; convention vs flexibility.|A node is a Python function receiving state and returning updates.|
|**[[Function Signatures]]**|Master the expected signature for node functions in graphs.|`(state: State) -> State`; typed parameters; optional returns; dict returns; state mutation vs return; typing.|Node signatures must match expected state types for graph integration.|
|**[[Synchronous vs Asynchronous Nodes]]**|Use async functions for I/O-bound operations and sync for CPU-bound logic.|async def for tool calls, API requests; sync def for logic, parsing; mixing in graphs; await semantics.|Use async nodes for API calls to avoid blocking graph execution.|
|**[[State Access Patterns]]**|Read and modify graph state correctly within node functions.|Full state access; field-by-field reading; accessing lists, nested objects; type safety; immutability.|Nodes read full state and return dict updates for specific fields.|
|**[[Return Value Patterns]]**|Return state updates correctly to thread state through the graph.|Return entire state; return dict of fields; return modifications; None handling; multiple update types.|Return updates ensure state changes propagate to the next node.|
|**[[Side Effects & Actions]]**|Use nodes for side effects like logging, API calls, or file I/O.|Separation of concerns; pure nodes vs effect nodes; logging levels; error handling in effects; recovery.|Side effects execute in nodes but shouldn't block pure control flow.|
|**[[Tool Invocation Nodes]]**|Implement nodes that call external tools or APIs within the agent.|Tool binding; function calling; error handling; timeout; retries; parsing tool results; state injection.|Tool nodes execute external functions and feed results back to state.|
|**[[LLM Invocation Nodes]]**|Create nodes that invoke language models and parse responses.|Loading models; prompt preparation; invoke/stream; token counting; cost tracking; parsing outputs; vision models.|LLM nodes are central thinking steps in most agent graphs.|
|**[[Decision/Routing Nodes]]**|Design nodes that make decisions affecting downstream execution.|Conditional logic; classification; ranking; routing decisions; state-based routing; determinism.|Decision nodes determine which downstream node executes next.|
|**[[Aggregation & Merge Nodes]]**|Combine outputs from parallel branches back into single state.|Merge strategies; reducer functions; consensus; conflict resolution; ordering dependencies; fanin patterns.|Merge nodes recombine state from divergent graph paths.|
|**[[Error Handling in Nodes]]**|Handle exceptions gracefully within node execution.|Try/except; fallback logic; error states; logging errors; recovery nodes; dead-letter paths.|Robust nodes handle failures without crashing the entire graph.|
|**[[Node Composition & Reuse]]**|Write reusable node functions that work across graphs.|Parametric nodes; factories; dependency injection; node libraries; generics; partial application.|Well-designed nodes generalize across different agent workflows.|
|**[[Stateful vs Stateless Nodes]]**|Understand node purity and dependencies on external state.|Pure functional nodes; side effects; dependencies on time/environment; testability; determinism.|Stateless nodes are easier to test and reason about.|
|**[[Testing Node Functions]]**|Write unit tests for individual node functions in isolation.|Fixtures; mock state; mock tools/LLMs; assertions on output; edge cases; integration tests.|Unit testing nodes before integration catches bugs early.|
|**[[Node Naming & Documentation]]**|Name and document nodes clearly for readability and maintenance.|Descriptive names; docstrings; parameter documentation; return type hints; type annotations; examples.|Clear names make graph readability obvious from code review.|
|**[[Performance Optimization in Nodes]]**|Optimize node execution for latency and resource usage.|Caching; batching; parallelism within node; streaming responses; memory efficiency; profiling.|Optimized nodes reduce overall graph latency and cost.|

