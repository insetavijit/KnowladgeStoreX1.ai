| **Section**                                        | **Focus**                | **Key Utilities / Concepts**                                                  | **One-Line Recall**                                                                                        |
| -------------------------------------------------- | ------------------------ | ----------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- |
| **[[1.1.5.1 Orchestration Overview]]**             | Tool-centric control     | LLM as orchestrator, tool graphs, decision policies, action routing           | Orchestration frames the LLM as a controller that coordinates tools to achieve goals.                      |
| **[[1.1.5.2 Function Calling in LLM APIs]]**       | Structured invocation    | OpenAI/Anthropic function calling, tool specs, arguments, deterministic calls | Function calling lets LLMs invoke tools with structured, machine-readable outputs.                         |
| **[[1.1.5.3 Tool Schemas & Contracts]]**           | Interface definition     | JSON Schema, type safety, input validation, output guarantees                 | Schemas define strict contracts between agents and tools.                                                  |
| **[[1.1.5.4 Tool Selection Logic]]**               | Decision making          | routing prompts, classifiers, scoring, rules vs LLM choice                    | Tool selection determines which capability to invoke for a given context.                                  |
| **[[1.1.5.5 Composing Tool Results]]**             | Result integration       | chaining outputs, intermediate state, aggregation, post-processing            | Agents combine multiple tool outputs to progress toward a solution.                                        |
| **[[1.1.5.6 Feedback Loops & Error Recovery]]**    | Robustness layer         | retries, fallbacks, exception handling, self-healing loops                    | Feedback loops help agents recover from tool failures and incorrect actions.                               |
| **[[1.1.5.7 Dynamic Tool Use]]**                   | Context-aware execution  | adaptive routing, conditional calls, context-driven selection                 | Dynamic tool use adapts actions based on runtime context and results.                                      |
| **[[1.1.5.8 Tool Result Validation]]**             | Trust & correctness      | schema checks, sanity rules, cross-validation, confidence scoring             | Validation ensures tool outputs are correct before being trusted.                                          |
| **[[1.1.5.9 Model Context Protocol (MCP)]]**       | Standardized tool access | MCP servers, capability discovery, unified interfaces                         | MCP standardizes how agents discover and use external tools.                                               |
| **[[1.1.5.10 Tools vs RAG vs Fine-Tuning]]**       | Capability strategy      | decision criteria, latency, cost, freshness, determinism                      | Choose tools, RAG, or fine-tuning based on whether you need actions, knowledge, or model behavior changes. |
| **[[1.1.5.11 Production Orchestration Patterns]]** | System-level design      | tool DAGs, supervisors, budgets, observability, tracing                       | Production agents orchestrate tools with control, monitoring, and cost discipline.                         |
