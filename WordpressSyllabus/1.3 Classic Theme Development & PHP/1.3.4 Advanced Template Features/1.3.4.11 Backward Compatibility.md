**Overview**  
Backward compatibility is the invisible infrastructure that keeps the WordPress ecosystem stable. For theme developers, it means ensuring that a theme remains functional across a specific range of WordPress and PHP versions, even as core APIs evolve or are deprecated. Building for backward compatibility requires a defensive programming mindsetâ€”using feature detection rather than version checks, providing fallbacks for newer block-based features, and maintaining support for legacy interfaces like classic widgets. A theme that respects backward compatibility builds long-term trust with users and ensures a wider market reach.

| **Section**                              | **Interview Learning Goals**                                          | **Key Technical Details to Study**                                                              |
| ---------------------------------------- | --------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------- |
| **[[BC Philosophy]]**                    | Explain why WordPress prioritizes backward compatibility.             | Market stability; preventing site breakage; user trust; "Decisions, not Options" philosophy.    |
| **[[Minimum Requirements]]**             | Describe defining supported WP and PHP versions.                      | `Requires at least` and `Requires PHP` headers in `style.css` and README.                      |
| **[[Feature Detection]]**                | Explain using `function_exists()` to avoid fatal errors.              | Checking for newer APIs like `wp_body_open()` or `register_block_type` before usage.           |
| **[[Pluggable Functions]]**              | Describe how old-school themes allow function overrides.              | `if ( ! function_exists() )` wrappers; child theme compatibility pattern.                      |
| **[[Deprecated Functions]]**             | Explain the lifecycle of a deprecated core function.                  | Moving to `deprecated.php`; log messages; using `_deprecated_function()` in your own code.      |
| **[[Legacy Widget Support]]**            | Discuss maintaining sidebars for the classic widget editor.           | `register_sidebar`; handling block-widgets in classic themes; backward-compatible markup.       |
| **[[Customizer Bridge]]**                | Describe supporting Site Editor features in Classic themes.           | The `Block-based Customizer`; bridge patterns; moving from `theme_mod` to `theme.json` support. |
| **[[Polyfills: PHP]]**                   | Explain adding support for newer PHP features in older environments.  | Back-porting functions like `str_starts_with`; using community polyfill libraries.             |
| **[[Polyfills: CSS/JS]]**                | Describe handling older browser compatibility (e.g., IE11 legacy).    | PostCSS autoprefixer; Babel transpiling; graceful degradation for CSS variables.               |
| **[[Fallback Template Hierarchy]]**      | Explain why `index.php` remains the ultimate fallback.                | Ensuring the theme renders something even if specific niche templates are missing.              |
| **[[wp_body_open() Hook]]**              | Describe why this hook was added in 5.2 and its fallback.             | Standardizing script injection; providing a direct fallback for older themes.                  |
| **[[Version Checking Best Practices]]**    | Discuss why feature detection is better than string version checks.   | Avoiding logic errors on customized or nightly WordPress builds.                               |
| **[[Plugin Compatibility]]**             | Explain handling major plugins (WooCommerce, ACF) across versions.    | Declaring support; checking plugin active status; providing fallbacks for missing assets.      |
| **[[Database Schemas]]**                 | Describe managing metadata transitions between theme versions.        | Migration scripts for post meta; updating serialized data formats without data loss.            |
| **[[Classic Editor Support]]**           | Discuss maintaining theme features for users who disable Gutenberg.   | Ensuring metaboxes and styles work correctly in the TinyMCE-based editor.                      |
| **[[Gutenberg Alignment]]**              | Explain providing block editor styles for classic template themes.    | `add_editor_style()`; ensuring the backend looks like the frontend in hybrid themes.           |
| **[[The _wp_theme_json Filter]]**        | Describe programmatically adjusting block settings in classic themes. | Faking `theme.json` settings via PHP filters for older theme architectures.                   |
| **[[Testing: WP_DEBUG]]**                | Explain identifying deprecated warnings during development.           | Enabling logs; identifying `_deprecated` calls; fixing legacy patterns early.                  |
| **[[Semantic Versioning]]**              | Describe how theme versioning communicates compatibility changes.     | Major vs Minor vs Patch releases; breaking changes vs backward-compatible fixes.              |
| **[[Best Practices]]**                   | Summarize the gold standard for backward-compatible development.      | Use feature detection; document requirements; provide graceful fallbacks; log deprecations.     |

If you want, I can continue with **1.3.4.12 Best Practices & UX** to expand it as well.
