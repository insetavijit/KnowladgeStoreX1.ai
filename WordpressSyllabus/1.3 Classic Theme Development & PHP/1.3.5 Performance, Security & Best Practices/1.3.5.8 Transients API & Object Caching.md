**Overview**  
Caching is the process of storing expensive data temporarily so that subsequent requests for the same data can be served much faster. In WordPress, there are two primary caching APIs for theme developers: the Transients API (which stores data in the database) and the Object Cache (which stores data in memory). Transients are ideal for data that is expensive to generate—like remote API responses or complex custom queries—and should persist across page loads. The Object Cache is designed for high-performance memory storage and requires a persistent backend like Redis or Memcached for long-term storage. Mastering these APIs allows a developer to bridge the gap between heavy, data-intensive features and a lightning-fast user experience.

| **Section**                              | **Interview Learning Goals**                                          | **Key Technical Details to Study**                                                              |
| ---------------------------------------- | --------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------- |
| **[[Caching Concept]]**                  | Explain why we cache data in the first place.                         | Reducing server load; improving TTFB; avoiding redundant expensive calculations.                |
| **[[The Transients API]]**               | Describe the purpose and behavior of transients.                      | Database-backed storage; expiration times; ideal for non-persistent environments.              |
| **[[set_transient()]]**                  | Identify saving data to a transient.                                  | `$key`, `$value`, `$expiration`; storage in `wp_options` table.                                |
| **[[get_transient()]]**                  | Explain the workflow for retrieving cached data.                      | Checking if the transient exists; returning the value or false (on expiration/missing).        |
| **[[delete_transient()]]**               | Describe manually clearing a cache.                                   | Cache invalidation; clearing data when the underlying source changes (e.g., on post save).      |
| **[[Transient Keys & Naming]]**          | Identify character limits and naming best practices.                   | 172 character limit; prefixing; ensuring unique keys for unique datasets.                      |
| **[[Expiration Strategies]]**            | Explain choosing the right TTL (Time To Live).                        | Short-term (minutes) vs Long-term (days); balancing data freshness with performance.           |
| **[[Caching Remote APIs]]**              | Describe use cases like social feeds or weather data.                 | Handling network latency; avoiding API rate limits; ensuring site stability during downtime.    |
| **[[The Object Cache API]]**             | Describe the role of `WP_Object_Cache`.                               | Non-persistent by default (single page load); in-memory; high speed retrieval.                 |
| **[[wp_cache_set() / get()]]**          | Identify the primary object caching functions.                        | Handling data within a single request; avoiding redundant DB hits in the same execution.       |
| **[[Persistent Object Caching]]**        | Explain why Redis or Memcached is needed for the Object Cache.        | Making memory storage last across page loads; significant boost for high-traffic sites.        |
| **[[Cache Groups]]**                     | Describe organizing cached data into logical sets.                    | Categorizing data for selective flushing; avoiding global cache pollution.                     |
| **[[Cache Invalidation Problem]]**       | Discuss the "Hardest Problem in CS": when to clear the cache.         | Preventing "stale" data; using hooks (e.g., `save_post`) to trigger deletion.                  |
| **[[Transients vs Options]]**            | Differentiate between permanent settings and temporary cache.          | Expiration vs Persistence; why transients are better for non-critical data.                    |
| **[[Site vs Network Transients]]**       | Explain `set_site_transient()` for Multisite networks.                 | Storing data shared across all sites in a network; global caching.                             |
| **[[WP_CACHE_KEY_SALT]]**                | Describe avoiding cache collisions in shared environments.            | Unique salting for object cache keys in multisite or shared server setups.                     |
| **[[Fragment Caching]]**                 | Explain caching specific chunks of template HTML.                     | Storing rendered components (e.g., a heavy menu) to bypass template processing completely.      |
| **[[Object Cache Globals]]**             | Discuss how core WordPress uses the Object Cache.                      | Options, metadata, and post data caching by core; why your theme should respect them.          |
| **[[Caching Large Objects]]**            | Describe the risks of caching massive datasets in transients.          | Database bloat; serialization overhead; better ways to store large structured data.            |
| **[[Best Practices]]**                   | Summarize the gold standard for data persistence.                     | Cache expensive results; always handle expiration; invalidate on update; use specific TTLs.     |

If you want, I can continue with **1.3.5.9 Asset Optimization** to cover frontend performance.
