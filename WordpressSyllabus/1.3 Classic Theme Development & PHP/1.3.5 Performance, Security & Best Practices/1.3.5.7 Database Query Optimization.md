**Overview**  
Database query optimization is the art of efficiently retrieving data from the WordPress database while minimizing the load on the server. Since WordPress is a data-driven CMS, the way a theme interacts with the database directly determines its scalability and speed. This involves mastering `WP_Query` arguments to limit fetched data, avoiding redundant queries through caching or bulk fetching (like `update_post_caches`), and understanding how to debug slow queries using tools like Query Monitor or the `EXPLAIN` statement in SQL. A professional developer knows that the most performant query is the one that is never run, followed closely by the one that only fetches exactly what is needed for the current view.

| **Section**                              | **Interview Learning Goals**                                          | **Key Technical Details to Study**                                                              |
| ---------------------------------------- | --------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------- |
| **[[WP_Query Fundamentals]]**            | Explain the cost of a standard loop.                                  | Main query vs supplemental queries; how WordPress builds the SQL from array arguments.         |
| **[[Limiting Fetched Fields]]**          | Describe fetching only IDs to save memory.                            | `fields => 'ids'`; reducing the overhead of full post objects when only IDs are needed.         |
| **[[The "N+1" Query Trap]]**            | Identify and fix redundant metadata queries inside loops.             | Problem: querying per row; Solution: bulk fetching meta before the loop starts.                |
| **[[update_post_caches()]]**             | Explain the value of pre-fetching post and meta data.                 | Warming the object cache; reducing DB hits during template iteration.                          |
| **[[no_found_rows Parameter]]**          | Describe disabling pagination counts for better speed.                 | `no_found_rows => true`; bypassing the expensive `SQL_CALC_FOUND_ROWS` statement.              |
| **[[Meta Query Performance]]**           | Explain why querying by metadata is slow at scale.                    | `meta_query` cost; absence of indexes on `meta_value`; impact of complex relationship queries.  |
| **[[Taxonomy Query Performance]]**       | Describe the efficiency of taxonomy-based filtering.                   | Why taxonomies are faster than custom fields for classification; indexing benefits.            |
| **[[Relationship Queries]]**             | Explain the cost of 'AND' vs 'OR' in complex queries.                | Join complexity; impact on query execution time in large datasets.                              |
| **[[Custom SQL vs WP_Query]]**            | Discuss when to use `$wpdb` directly for speed.                       | Complex joins not supported by `WP_Query`; performance vs maintainability trade-offs.           |
| **[[Database Indexing Basics]]**         | Describe how indexes speed up data retrieval.                         | Primary keys; foreign keys; why searching non-indexed columns causes "full table scans".       |
| **[[Slow Query Debugging]]**             | Identify how to find bottleneck queries.                              | `SAVEQUERIES` constant; using Query Monitor to see execution time and caller info.             |
| **[[SQL_CALC_FOUND_ROWS]]**              | Explain the performance impact of counting total pages.                | Why large datasets slow down when pagination is calculated; alternatives like "Load More".     |
| **[[Orderby performance]]**              | Describe the cost of sorting by random or non-indexed fields.          | `orderby => 'rand'` cost; sorting by meta values; efficiency of sorting by date/ID.            |
| **[[Suppressing Hooks]]**                | Explain using `suppress_filters => true`.                             | Preventing other plugins from modifying your query; slight performance gain.                  |
| **[[Querying the Options Table]]**       | Describe the overhead of many small option requests.                  | Autoloaded options; using arrays to store related settings instead of many single options.     |
| **[[The EXPLAIN Statement]]**            | Explain using SQL `EXPLAIN` to analyze query execution plans.         | Identifying used indexes, row scans, and temporary tables in custom SQL.                       |
| **[[Object Caching Integration]]**       | Describe how `WP_Query` interacts with the Object Cache.              | Persistent cache benefits; why a warm cache is faster than any optimized SQL.                 |
| **[[Bulk Data Processing]]**             | Describe handling thousands of records safely.                        | Using batching; offset vs chunking for memory management in migrations.                        |
| **[[Database Cleanup]]**                 | Identify the performance impact of bloated DBs.                       | Revisions; orphaned meta; transient leftovers; impact on overall site responsiveness.           |
| **[[Best Practices]]**                   | Summarize the gold standard for database efficiency.                  | Fetch only what you need; avoid meta queries if possible; use caching; monitor query counts.    |

If you want, I can continue with **1.3.5.8 Transients API & Object Caching** to cover data persistence.
