Type checking and inspection in Python are mechanisms for **determining and verifying the type of an object at runtime**. Unlike statically typed languages where types are verified at compile time, Python resolves types during execution, making runtime inspection essential for defensive programming, debugging, and dynamic behavior.

Understanding type checking requires distinguishing between **identity** (`type()`), **inheritance** (`isinstance()`), and **capability** (duck typing). Each serves a different purpose and has different trade-offs.

---

## The Fundamental Principle: Runtime Type Resolution

In Python, types are properties of **objects**, not variables. Type checking always happens at runtime by inspecting the object currently referenced.

```python
x = 42
print(type(x))  # <class 'int'>

x = "hello"
print(type(x))  # <class 'str'>
```

The type changes because the object changes, not because `x` itself has a type.

---

## Core Functions

### `type()`: Exact Type

`type()` returns the **exact type** of an object:

```python
print(type(42))         # <class 'int'>
print(type(3.14))       # <class 'float'>
print(type("hello"))    # <class 'str'>
print(type([1, 2, 3]))  # <class 'list'>
```

You can use `type()` for equality checks:

```python
if type(value) == int:
    print("Exactly an int")
```

**Limitation**: `type()` checks for **exact type match**, ignoring inheritance.

```python
class MyInt(int):
    pass

x = MyInt(10)
print(type(x) == int)  # False (it's MyInt, not int)
```

---

### `isinstance()`: Type with Inheritance

`isinstance()` checks if an object is an instance of a class **or any of its subclasses**:

```python
isinstance(42, int)         # True
isinstance(3.14, float)     # True
isinstance("hello", str)    # True
isinstance([1, 2], list)    # True
```

It respects inheritance:

```python
class MyInt(int):
    pass

x = MyInt(10)
print(isinstance(x, int))  # True (MyInt is a subclass of int)
print(type(x) == int)      # False (exact type is MyInt)
```

You can check multiple types:

```python
isinstance(42, (int, float))  # True (is it int OR float?)
isinstance("hello", (int, float))  # False
```

---

## `type()` vs. `isinstance()`

| Feature | `type()` | `isinstance()` |
| :--- | :--- | :--- |
| **Checks** | Exact type | Type or subclass |
| **Inheritance** | Ignores | Respects |
| **Multiple Types** | No | Yes (`isinstance(x, (int, str))`) |
| **Recommended** | Rarely | Usually |

**Best Practice**: Use `isinstance()` unless you specifically need exact type matching.

---

## Checking for None

For `None`, use **identity check** (`is`), not type checking:

```python
# Correct
if value is None:
    print("No value")

# Incorrect (works, but less idiomatic)
if isinstance(value, type(None)):
    print("No value")
```

---

## Duck Typing: Behavior Over Type

Python's philosophy is **"If it walks like a duck and quacks like a duck, it's a duck."**

Instead of checking types, check **capabilities**:

```python
# Type-based (rigid)
if isinstance(obj, list):
    obj.append(item)

# Duck-typed (flexible)
if hasattr(obj, 'append'):
    obj.append(item)
```

This works with any object that has an `append` method, not just lists.

### `hasattr()`: Check for Attributes

```python
hasattr(obj, 'append')  # Does obj have an 'append' attribute?
hasattr(obj, 'read')    # Does obj have a 'read' method?
```

### `callable()`: Check if Callable

```python
def greet():
    print("Hello")

print(callable(greet))  # True
print(callable(42))     # False
```

---

## Advanced Inspection

### `dir()`: List Attributes

`dir()` returns all attributes and methods of an object:

```python
x = [1, 2, 3]
print(dir(x))  # ['append', 'clear', 'copy', 'count', ...]
```

### `getattr()`: Get Attribute Dynamically

```python
x = [1, 2, 3]
method = getattr(x, 'append')
method(4)
print(x)  # [1, 2, 3, 4]
```

With a default:

```python
value = getattr(obj, 'missing_attr', None)  # Returns None if not found
```

### `setattr()`: Set Attribute Dynamically

```python
class User:
    pass

user = User()
setattr(user, 'name', 'Alice')
print(user.name)  # Alice
```

---

## Type Checking Patterns

### Pattern 1: Validate Input

```python
def add(a, b):
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise TypeError("Arguments must be numbers")
    return a + b
```

### Pattern 2: Polymorphic Functions

```python
def process(data):
    if isinstance(data, str):
        return data.upper()
    elif isinstance(data, list):
        return [process(item) for item in data]
    else:
        return str(data)
```

### Pattern 3: Optional Type Checking

```python
def save(data, writer):
    if not hasattr(writer, 'write'):
        raise TypeError("Writer must have a 'write' method")
    writer.write(data)
```

---

## Static Type Checking (mypy)

Python also supports **static type checking** using tools like `mypy`. This analyzes code **without running it**:

```python
def add(a: int, b: int) -> int:
    return a + b

add(10, "20")  # mypy error: Argument 2 has incompatible type "str"
```

Static checking catches errors early but doesn't affect runtime behavior.

---

## Common Pitfalls

### Pitfall 1: Using `type()` Instead of `isinstance()`

```python
# Bad: Breaks with subclasses
if type(value) == int:
    process(value)

# Good: Works with subclasses
if isinstance(value, int):
    process(value)
```

### Pitfall 2: Over-Checking Types

```python
# Over-engineered
def add(a, b):
    if not isinstance(a, int) or not isinstance(b, int):
        raise TypeError("Must be ints")
    return a + b
```

This rejects `float`, `bool`, and custom numeric types. Better:

```python
# Duck-typed
def add(a, b):
    return a + b  # Let Python handle invalid types
```

### Pitfall 3: Checking for `None` with `isinstance()`

```python
# Awkward
if isinstance(value, type(None)):
    print("None")

# Correct
if value is None:
    print("None")
```

---

## Quick Reference

| Function | Purpose | Example |
| :--- | :--- | :--- |
| `type(obj)` | Get exact type | `type(42)` → `<class 'int'>` |
| `isinstance(obj, type)` | Check type (with inheritance) | `isinstance(42, int)` → `True` |
| `hasattr(obj, 'attr')` | Check if attribute exists | `hasattr([], 'append')` → `True` |
| `callable(obj)` | Check if callable | `callable(print)` → `True` |
| `dir(obj)` | List attributes | `dir([])` → `['append', ...]` |
| `getattr(obj, 'attr')` | Get attribute dynamically | `getattr([], 'append')` |
| `setattr(obj, 'attr', val)` | Set attribute dynamically | `setattr(obj, 'x', 10)` |

---

## A Coherent System

Type checking in Python is **runtime-based** and **flexible**:

*   **`isinstance()`**: Preferred for most type checks (respects inheritance).
*   **Duck Typing**: Check capabilities (`hasattr()`) instead of types when possible.
*   **`type()`**: Use only when exact type matching is required.

**The essence:** Type checking in Python happens at runtime by inspecting objects. Use `isinstance()` for inheritance-aware checks, duck typing for flexibility, and `type()` only when exact type matching is necessary.
