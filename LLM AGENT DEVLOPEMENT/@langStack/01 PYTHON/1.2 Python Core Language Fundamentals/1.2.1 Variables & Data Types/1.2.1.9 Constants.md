Constants in Python are **values that should not change** after initialization. Unlike languages like C++ or Java, Python has **no language-level enforcement** of constants. Instead, constants are a **social convention** communicated through naming: values in `UPPER_CASE_WITH_UNDERSCORES` signal "do not modify this."

Understanding constants in Python requires recognizing the difference between **technical immutability** (enforced by the language) and **semantic immutability** (enforced by discipline and convention).

---

## The Fundamental Principle: Convention Over Enforcement

Python does not have a `const` keyword. You cannot declare a variable as "constant" in a way that prevents reassignment. Instead, Python relies on **naming conventions** to signal intent.

```python
MAX_CONNECTIONS = 100
API_BASE_URL = "https://api.example.com"
DEFAULT_TIMEOUT = 30
```

These names communicate: "This value is configuration. Don't change it."

But Python will not stop you from doing this:

```python
MAX_CONNECTIONS = 200  # No error, but violates convention
```

The convention is a **promise between developers**, not a technical constraint.

---

## Why Constants Matter

### 1. Readability

Magic numbers and strings scattered throughout code are hard to understand:

```python
# Bad: What is 86400?
if elapsed_time > 86400:
    send_reminder()
```

Constants make intent explicit:

```python
# Good: Clear meaning
SECONDS_PER_DAY = 86400
if elapsed_time > SECONDS_PER_DAY:
    send_reminder()
```

### 2. Maintainability

When a value appears in multiple places, changing it requires finding all occurrences. Constants centralize configuration:

```python
# Bad: Repeated literal
timeout = 30
connection = connect(timeout=30)
retry_after = 30
```

```python
# Good: Single source of truth
DEFAULT_TIMEOUT = 30
timeout = DEFAULT_TIMEOUT
connection = connect(timeout=DEFAULT_TIMEOUT)
retry_after = DEFAULT_TIMEOUT
```

Now, changing the timeout requires updating one line.

### 3. Type Safety (with Type Hints)

Constants can be annotated with types:

```python
MAX_RETRIES: int = 3
API_KEY: str = "secret"
```

Static type checkers can verify that constants are used correctly.

---

## Naming Convention: UPPER_CASE

Constants use `SCREAMING_SNAKE_CASE`:

```python
PI = 3.14159
MAX_SIZE = 1024
DATABASE_URL = "postgresql://localhost/db"
```

This convention is defined in **PEP 8**, Python's official style guide.

---

## Where to Define Constants

### Module-Level Constants

Most constants are defined at the **top of a module**:

```python
# config.py
MAX_CONNECTIONS = 100
API_BASE_URL = "https://api.example.com"
DEFAULT_TIMEOUT = 30
```

Other modules can import them:

```python
from config import MAX_CONNECTIONS, API_BASE_URL
```

### Class-Level Constants

Constants related to a class can be defined as class attributes:

```python
class Circle:
    PI = 3.14159
    
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return Circle.PI * self.radius ** 2
```

---

## Immutability: Technical vs. Semantic

### Technical Immutability

Some types are **immutable by design**: `int`, `float`, `str`, `tuple`. You cannot modify their values in place.

```python
PI = 3.14159
PI += 0.00001  # Creates a new float, rebinds PI
```

This doesn't modify the original `3.14159` objectâ€”it creates a new object and rebinds `PI` to it.

### Semantic Immutability

For **mutable types** (like `list` or `dict`), the convention is weaker:

```python
DEFAULT_SETTINGS = {"timeout": 30, "retries": 3}
DEFAULT_SETTINGS["timeout"] = 60  # Modifies the dict (bad practice!)
```

To prevent this, use **immutable alternatives**:

```python
# Use tuple instead of list
ALLOWED_EXTENSIONS = ("jpg", "png", "gif")

# Use types.MappingProxyType for read-only dicts
from types import MappingProxyType

_SETTINGS = {"timeout": 30, "retries": 3}
DEFAULT_SETTINGS = MappingProxyType(_SETTINGS)

DEFAULT_SETTINGS["timeout"] = 60  # TypeError: does not support item assignment
```

---

## Enforcing Constants (Advanced)

If you need **true enforcement**, you can use advanced techniques:

### 1. `typing.Final` (Type Hint)

```python
from typing import Final

MAX_SIZE: Final = 1024
```

This is a **hint to static type checkers** (like `mypy`), not runtime enforcement:

```python
MAX_SIZE = 2048  # mypy error, but runs fine
```

### 2. Property with No Setter

```python
class Config:
    @property
    def max_size(self):
        return 1024

config = Config()
print(config.max_size)  # 1024
config.max_size = 2048  # AttributeError: can't set attribute
```

### 3. `__setattr__` Override

```python
class Constants:
    MAX_SIZE = 1024
    
    def __setattr__(self, name, value):
        raise AttributeError(f"Cannot modify constant {name}")

constants = Constants()
constants.MAX_SIZE = 2048  # AttributeError
```

These are rarely used in practice. The naming convention is usually sufficient.

---

## Common Patterns

### Pattern 1: Configuration Constants

```python
# settings.py
DATABASE_URL = "postgresql://localhost/db"
SECRET_KEY = "your-secret-key"
DEBUG = True
```

### Pattern 2: Enumerations (Before `enum`)

Before Python 3.4's `enum` module, constants were used for enumerations:

```python
# Status codes
STATUS_PENDING = 0
STATUS_APPROVED = 1
STATUS_REJECTED = 2
```

Now, use `enum.Enum`:

```python
from enum import Enum

class Status(Enum):
    PENDING = 0
    APPROVED = 1
    REJECTED = 2
```

### Pattern 3: Mathematical Constants

```python
import math

PI = math.pi
E = math.e
```

---

## Common Pitfalls

### Pitfall 1: Modifying Mutable Constants

```python
DEFAULT_OPTIONS = []
DEFAULT_OPTIONS.append("new")  # Modifies the "constant"
```

**Fix**: Use immutable types or `MappingProxyType`.

### Pitfall 2: Lowercase Constants

```python
max_size = 1024  # Looks like a variable, not a constant
```

**Fix**: Use `UPPER_CASE`.

### Pitfall 3: Reassigning Constants

```python
MAX_SIZE = 1024
# ... later in code ...
MAX_SIZE = 2048  # Violates convention
```

**Fix**: Don't reassign. If you need a variable value, use a regular variable.

---

## Quick Reference

| Concept | Syntax | Notes |
| :--- | :--- | :--- |
| **Naming** | `UPPER_CASE_WITH_UNDERSCORES` | PEP 8 convention |
| **Scope** | Module-level or class-level | Define at top of module |
| **Immutability** | Use immutable types (`int`, `str`, `tuple`) | Prevents accidental modification |
| **Type Hint** | `MAX_SIZE: Final = 1024` | Hint for static checkers |
| **Read-Only Dict** | `MappingProxyType(dict)` | Prevents modification |

---

## A Coherent System

Constants in Python are **convention-based**, not language-enforced:

*   **Naming**: `UPPER_CASE` signals "do not modify."
*   **Immutability**: Prefer immutable types for technical safety.
*   **Discipline**: Respect the convention; don't reassign constants.

**The essence:** Constants in Python are values that should not change, communicated through `UPPER_CASE` naming. While the language doesn't enforce immutability, the convention is a social contract that improves readability and maintainability.
