Type hints in Python, formalized in PEP 484, are **optional annotations** that document the expected types of variables, function parameters, and return values. They do not change Python's runtime behavior—the interpreter ignores them completely. Instead, they serve as **machine-readable documentation** for developers, IDEs, and static analysis tools.

Understanding type hints requires recognizing what they are *not*: they are not type declarations, not runtime constraints, and not a replacement for dynamic typing. They are a **parallel type system** that coexists with Python's dynamic nature.

---

## The Fundamental Principle: Documentation, Not Enforcement

Type hints are **metadata**. They describe intent without enforcing it.

```python
def greet(name: str) -> str:
    return f"Hello, {name}"
```

This function signature says:
*   `name` is expected to be a `str`
*   The function is expected to return a `str`

But Python will not stop you from doing this:

```python
result = greet(42)  # No error at runtime
print(result)       # "Hello, 42"
```

The type hint is a **promise to the reader and to tools**, not a command to the interpreter.

---

## Why Type Hints Exist

In a dynamically typed language, the biggest challenge is **understanding what types a function expects** without reading its implementation.

### Before Type Hints

```python
def calculate_discount(price, rate):
    return price * rate
```

Questions a reader might have:
*   Is `price` a float? An int? A Decimal?
*   Is `rate` a percentage (0-100) or a fraction (0-1)?
*   What does the function return?

You must read the function body or documentation to find out.

### After Type Hints

```python
def calculate_discount(price: float, rate: float) -> float:
    return price * rate
```

Now the contract is explicit. The function expects two floats and returns a float. This is **self-documenting code**.

---

## Basic Syntax

### Variable Annotations

```python
name: str = "Alice"
age: int = 30
price: float = 19.99
is_active: bool = True
```

The annotation comes after the variable name, separated by a colon.

### Function Annotations

```python
def add(a: int, b: int) -> int:
    return a + b
```

*   Parameter types: `a: int`, `b: int`
*   Return type: `-> int`

### No Annotation for Return

If a function doesn't return a value (returns `None` implicitly), use `-> None`:

```python
def log_message(message: str) -> None:
    print(message)
```

---

## Advanced Type Hints

### Optional Types

Use `Optional[T]` to indicate a value can be `T` or `None`:

```python
from typing import Optional

def find_user(user_id: int) -> Optional[str]:
    if user_id == 1:
        return "Alice"
    return None
```

`Optional[str]` is shorthand for `Union[str, None]`.

### Union Types

Use `Union[T1, T2]` to indicate a value can be one of several types:

```python
from typing import Union

def process(value: Union[int, str]) -> str:
    return str(value)
```

In Python 3.10+, you can use the `|` operator:

```python
def process(value: int | str) -> str:
    return str(value)
```

### Collections

Use generic types from `typing` to annotate collections:

```python
from typing import List, Dict, Set, Tuple

names: List[str] = ["Alice", "Bob"]
ages: Dict[str, int] = {"Alice": 30, "Bob": 25}
tags: Set[str] = {"python", "code"}
coordinates: Tuple[int, int] = (10, 20)
```

In Python 3.9+, you can use built-in types directly:

```python
names: list[str] = ["Alice", "Bob"]
ages: dict[str, int] = {"Alice": 30}
```

### Callable Types

Use `Callable` to annotate functions:

```python
from typing import Callable

def apply(func: Callable[[int, int], int], a: int, b: int) -> int:
    return func(a, b)

def add(x: int, y: int) -> int:
    return x + y

result = apply(add, 10, 20)  # 30
```

`Callable[[int, int], int]` means: a function that takes two `int` arguments and returns an `int`.

### Any Type

Use `Any` to opt out of type checking for a specific value:

```python
from typing import Any

def process(data: Any) -> str:
    return str(data)
```

`Any` is compatible with all types. Use it sparingly—it defeats the purpose of type hints.

---

## Type Hints and Static Analysis

Type hints are designed for **static type checkers** like `mypy`, `pyright`, and `pyre`. These tools analyze your code without running it and report type errors.

### Example

```python
def add(a: int, b: int) -> int:
    return a + b

result = add(10, "20")  # Type error (caught by mypy)
```

Running `mypy`:

```
$ mypy script.py
script.py:4: error: Argument 2 to "add" has incompatible type "str"; expected "int"
```

The code runs fine in Python, but `mypy` catches the type mismatch.

---

## Type Hints and IDEs

Modern IDEs (VS Code, PyCharm, etc.) use type hints to provide:

*   **Autocomplete**: Suggest methods available on typed objects.
*   **Error Detection**: Highlight type mismatches before you run the code.
*   **Refactoring**: Safely rename variables and functions with type awareness.

### Example

```python
def get_user() -> dict[str, str]:
    return {"name": "Alice", "email": "alice@example.com"}

user = get_user()
user.  # IDE suggests: .get(), .keys(), .values(), etc.
```

Without type hints, the IDE can't know that `user` is a dict.

---

## When to Use Type Hints

### Use Type Hints When:

1.  **Public APIs**: Functions and classes intended for others to use.
2.  **Complex Logic**: Functions with non-obvious parameter types.
3.  **Large Codebases**: Where understanding types from context is difficult.
4.  **Team Projects**: Where multiple developers need to understand each other's code.

### Skip Type Hints When:

1.  **Prototyping**: Rapid experimentation where types are in flux.
2.  **Obvious Types**: `def add_one(x: int) -> int: return x + 1` is arguably over-annotated.
3.  **Scripts**: Small, throwaway scripts where the overhead isn't worth it.

---

## Common Pitfalls

### Pitfall 1: Over-Annotation

```python
# Excessive
x: int = 10
y: int = 20
result: int = x + y
```

The types are obvious from the literals. This is noise.

### Pitfall 2: Incorrect Hints

```python
def get_user() -> dict:
    return None  # Violates the hint
```

Incorrect hints are worse than no hints—they mislead readers and tools.

### Pitfall 3: Confusing Hints with Enforcement

```python
def add(a: int, b: int) -> int:
    return a + b

add("10", "20")  # No runtime error!
```

Type hints don't prevent this. Use a static checker if you want enforcement.

---

## Quick Reference

| Annotation | Meaning |
| :--- | :--- |
| `x: int` | `x` is expected to be an `int` |
| `x: str` | `x` is expected to be a `str` |
| `x: list[int]` | `x` is a list of integers |
| `x: dict[str, int]` | `x` is a dict mapping strings to integers |
| `x: Optional[str]` | `x` is a string or `None` |
| `x: Union[int, str]` | `x` is an int or a string |
| `x: Any` | `x` can be any type (opt-out) |
| `-> None` | Function returns `None` |
| `-> int` | Function returns an `int` |
| `Callable[[int], str]` | Function taking an `int` and returning a `str` |

---

## A Coherent System

Type hints are Python's answer to the question: *"How do we get the benefits of static typing without sacrificing dynamic flexibility?"*

The answer is **gradual typing**: a system where types are optional, non-enforced, and can be added incrementally. You can:
*   Start with no hints (pure dynamic).
*   Add hints to critical functions (hybrid).
*   Fully annotate your codebase (static-like).

**The essence:** Type hints are a parallel type system that documents intent without constraining runtime behavior. They enable better tooling, clearer code, and safer refactoring—while preserving Python's dynamic nature.
