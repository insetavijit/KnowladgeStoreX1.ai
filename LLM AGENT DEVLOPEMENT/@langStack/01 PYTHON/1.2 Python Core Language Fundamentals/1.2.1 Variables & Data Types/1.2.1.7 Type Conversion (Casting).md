Type conversion (also called **casting**) in Python is the process of explicitly transforming a value from one type to another. Unlike implicit conversion (coercion), which happens automatically in some languages, Python requires **explicit conversion** for most type changes.

This design choice reflects Python's philosophy: **explicit is better than implicit**. Type conversion is not automatic magic—it is a deliberate operation with clear semantics and predictable failure modes.

---

## The Fundamental Principle: Explicit Conversion

Python is **strongly typed**, meaning it will not silently convert types in ambiguous situations. If you want to combine incompatible types, you must explicitly convert one of them.

```python
# This fails:
result = "10" + 5  # TypeError: can only concatenate str (not "int") to str

# This works:
result = int("10") + 5  # 15 (string converted to int)
result = "10" + str(5)  # "105" (int converted to string)
```

The error is intentional. Python forces you to decide: do you want numeric addition or string concatenation?

---

## Core Conversion Functions

Python provides built-in functions for converting between primitive types:

| Function | Purpose | Example |
| :--- | :--- | :--- |
| `int()` | Convert to integer | `int("42")` → `42` |
| `float()` | Convert to float | `float("3.14")` → `3.14` |
| `str()` | Convert to string | `str(100)` → `"100"` |
| `bool()` | Convert to boolean | `bool(1)` → `True` |

---

## Converting to Integer: `int()`

### From String

```python
int("42")      # 42
int("-17")     # -17
int("0xFF", 16)  # 255 (hexadecimal)
int("1010", 2)   # 10 (binary)
```

**Failure cases:**

```python
int("hello")   # ValueError: invalid literal for int()
int("3.14")    # ValueError: invalid literal for int()
int("")        # ValueError: invalid literal for int()
```

Strings must represent valid integers. Floats in string form are not accepted.

### From Float

```python
int(3.14)   # 3 (truncates, doesn't round)
int(3.99)   # 3
int(-2.7)   # -2
```

Conversion **truncates toward zero**, not rounds.

### From Boolean

```python
int(True)   # 1
int(False)  # 0
```

Booleans are a subclass of `int`, so this is trivial.

---

## Converting to Float: `float()`

### From String

```python
float("3.14")    # 3.14
float("-0.5")    # -0.5
float("1e-10")   # 1e-10 (scientific notation)
float("inf")     # inf (infinity)
float("-inf")    # -inf
float("nan")     # nan (not a number)
```

**Failure cases:**

```python
float("hello")  # ValueError: could not convert string to float
```

### From Integer

```python
float(10)   # 10.0
float(-5)   # -5.0
```

Always produces a float with `.0` suffix.

### From Boolean

```python
float(True)   # 1.0
float(False)  # 0.0
```

---

## Converting to String: `str()`

`str()` works on **any object** because every Python object has a string representation.

```python
str(42)         # "42"
str(3.14)       # "3.14"
str(True)       # "True"
str([1, 2, 3])  # "[1, 2, 3]"
str(None)       # "None"
```

This is the most forgiving conversion—it never fails.

---

## Converting to Boolean: `bool()`

`bool()` converts any value to `True` or `False` based on **truthiness**.

### Falsy Values (convert to `False`):

*   `False`
*   `None`
*   `0`, `0.0`, `0j` (numeric zeros)
*   `""` (empty string)
*   `[]`, `{}`, `set()`, `()` (empty collections)

### Truthy Values (convert to `True`):

*   Everything else

```python
bool(1)         # True
bool(-1)        # True
bool("hello")   # True
bool([1, 2])    # True

bool(0)         # False
bool("")        # False
bool([])        # False
bool(None)      # False
```

---

## Implicit Conversion (Rare)

Python performs **limited implicit conversion** in specific contexts:

### Numeric Promotion

When mixing numeric types, Python promotes to the "wider" type:

```python
10 + 3.5      # 13.5 (int promoted to float)
True + 5      # 6 (bool promoted to int)
```

### Boolean Context

In conditionals, any value is implicitly converted to boolean:

```python
if [1, 2, 3]:  # Non-empty list is truthy
    print("Has items")
```

This is equivalent to `if bool([1, 2, 3]):`, but the `bool()` call is implicit.

---

## Safe Conversion Patterns

### Handling Invalid Input

Type conversion can fail. Robust code anticipates this:

```python
# Unsafe
user_input = "abc"
age = int(user_input)  # ValueError

# Safe
try:
    age = int(user_input)
except ValueError:
    age = None  # or a default value
```

### Validation Before Conversion

```python
def safe_int(value: str) -> int | None:
    if value.isdigit():
        return int(value)
    return None

age = safe_int("25")  # 25
age = safe_int("abc")  # None
```

---

## Conversion vs. Coercion

It's important to distinguish:

| Term | Meaning | Example |
| :--- | :--- | :--- |
| **Conversion** | Explicit transformation | `int("10")` |
| **Coercion** | Implicit transformation | `10 + 3.5` → `13.5` |

Python minimizes coercion to avoid ambiguity. Most type changes require explicit conversion.

---

## Common Pitfalls

### Pitfall 1: Truncation vs. Rounding

```python
int(3.9)  # 3 (not 4!)
```

If you want rounding, use `round()`:

```python
round(3.9)  # 4
```

### Pitfall 2: String to Int with Floats

```python
int("3.14")  # ValueError
```

You must convert to float first:

```python
int(float("3.14"))  # 3
```

### Pitfall 3: Truthiness Confusion

```python
bool("False")  # True (non-empty string is truthy!)
```

The string `"False"` is not the boolean `False`. It's a non-empty string, which is truthy.

---

## Advanced Conversions

### Collections

```python
list("abc")       # ['a', 'b', 'c']
tuple([1, 2, 3])  # (1, 2, 3)
set([1, 2, 2, 3]) # {1, 2, 3}
dict([("a", 1), ("b", 2)])  # {'a': 1, 'b': 2}
```

### Custom Objects

You can define how your objects convert to built-in types:

```python
class Temperature:
    def __init__(self, celsius):
        self.celsius = celsius
    
    def __int__(self):
        return int(self.celsius)
    
    def __float__(self):
        return float(self.celsius)
    
    def __str__(self):
        return f"{self.celsius}°C"

temp = Temperature(25.7)
print(int(temp))    # 25
print(float(temp))  # 25.7
print(str(temp))    # "25.7°C"
```

---

## Quick Reference

| Conversion | Syntax | Notes |
| :--- | :--- | :--- |
| String → Int | `int("42")` | Fails on invalid format |
| String → Float | `float("3.14")` | Supports scientific notation |
| Int → String | `str(42)` | Always succeeds |
| Float → Int | `int(3.14)` | Truncates (doesn't round) |
| Any → Bool | `bool(value)` | Based on truthiness |
| Any → String | `str(value)` | Always succeeds |

---

## A Coherent System

Type conversion in Python is **explicit, predictable, and safe**:

*   **Explicit**: You must request conversion; it's never hidden.
*   **Predictable**: Conversion rules are well-defined and consistent.
*   **Safe**: Invalid conversions raise exceptions rather than producing garbage.

**The essence:** Type conversion in Python is a deliberate operation that transforms values between compatible types. It requires explicit intent, fails loudly on invalid input, and preserves Python's strong typing guarantees.
