Comparison operators in Python are not simple equality checks—they are **protocols for ordering and equivalence**. Each comparison invokes specific methods on objects, and the result depends on how those objects define their comparison behavior.

Understanding comparison operators requires recognizing that Python distinguishes between **value equality** (`==`), **identity** (`is`), and **ordering** (`<`, `>`, etc.). Each serves a different purpose and operates at a different conceptual level.

---

## The Fundamental Principle: Equality vs. Identity

Python provides two fundamentally different ways to compare objects:

1.  **Value Equality (`==`)**: Do these objects represent the same value?
2.  **Identity (`is`)**: Are these the exact same object in memory?

```python
a = [1, 2, 3]
b = [1, 2, 3]
c = a

print(a == b)  # True (same value)
print(a is b)  # False (different objects)
print(a is c)  # True (same object)
```

This distinction is critical. `==` compares **what** objects contain; `is` compares **where** they live.

---

## The Comparison Operators

### Equality: `==`

Tests if two objects have **equal values**.

```python
10 == 10        # True
"hello" == "hello"  # True
[1, 2] == [1, 2]    # True (same contents)
```

**Method call**: `a == b` invokes `a.__eq__(b)`.

Custom classes can define what equality means:

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

p1 = Point(1, 2)
p2 = Point(1, 2)
print(p1 == p2)  # True (same coordinates)
print(p1 is p2)  # False (different objects)
```

### Inequality: `!=`

Tests if two objects have **different values**.

```python
10 != 5         # True
"hello" != "world"  # True
[1, 2] != [1, 2]    # False (same contents)
```

**Method call**: `a != b` invokes `a.__ne__(b)`.

By default, `!=` is the negation of `==`, but it can be overridden independently.

### Less Than: `<`

Tests if the left operand is **strictly less than** the right.

```python
5 < 10      # True
"a" < "b"   # True (lexicographic order)
```

**Method call**: `a < b` invokes `a.__lt__(b)`.

### Less Than or Equal: `<=`

Tests if the left operand is **less than or equal to** the right.

```python
5 <= 10     # True
10 <= 10    # True
```

**Method call**: `a <= b` invokes `a.__le__(b)`.

### Greater Than: `>`

Tests if the left operand is **strictly greater than** the right.

```python
10 > 5      # True
"b" > "a"   # True
```

**Method call**: `a > b` invokes `a.__gt__(b)`.

### Greater Than or Equal: `>=`

Tests if the left operand is **greater than or equal to** the right.

```python
10 >= 5     # True
10 >= 10    # True
```

**Method call**: `a >= b` invokes `a.__ge__(b)`.

---

## Identity Comparison: `is` and `is not`

### Identity: `is`

Tests if two names refer to the **exact same object** in memory.

```python
a = [1, 2, 3]
b = a
c = [1, 2, 3]

print(a is b)  # True (same object)
print(a is c)  # False (different objects)
```

**Use case**: Checking for `None`.

```python
if value is None:
    print("No value")
```

### Not Identity: `is not`

Tests if two names refer to **different objects**.

```python
a = [1, 2, 3]
b = [1, 2, 3]

print(a is not b)  # True (different objects)
```

---

## Type-Specific Comparison Behavior

### Numeric Comparisons

Numbers are compared by **mathematical value**, with automatic type promotion:

```python
10 == 10.0      # True (int promoted to float)
True == 1       # True (bool promoted to int)
False == 0      # True
```

### String Comparisons

Strings are compared **lexicographically** (dictionary order) using Unicode code points:

```python
"apple" < "banana"  # True
"Apple" < "apple"   # True (uppercase comes before lowercase)
"10" < "2"          # True (string comparison, not numeric)
```

### List and Tuple Comparisons

Sequences are compared **element-by-element** from left to right:

```python
[1, 2, 3] < [1, 2, 4]  # True (3 < 4)
[1, 2] < [1, 2, 3]     # True (shorter is less)
```

The first differing element determines the result.

### Dictionary Comparisons

Dictionaries support **equality** but not ordering:

```python
{"a": 1} == {"a": 1}  # True
{"a": 1} < {"b": 2}   # TypeError: '<' not supported
```

---

## Chaining Comparisons

Python allows **chaining** multiple comparisons, which is evaluated left-to-right with short-circuiting:

```python
x = 5
print(1 < x < 10)  # True (equivalent to: 1 < x and x < 10)
```

This is more readable than:

```python
print(1 < x and x < 10)
```

**Short-circuit evaluation**: If any comparison fails, the rest are not evaluated:

```python
def expensive():
    print("Called!")
    return 10

x = 0
print(x > 5 < expensive())  # False (expensive() never called)
```

---

## Common Patterns

### Pattern 1: Checking for None

Always use `is`, not `==`:

```python
# Correct
if value is None:
    print("No value")

# Incorrect (works, but less efficient)
if value == None:
    print("No value")
```

### Pattern 2: Range Checking

Use chained comparisons:

```python
age = 25
if 18 <= age < 65:
    print("Working age")
```

### Pattern 3: Sorting with Custom Key

```python
users = [{"name": "Alice", "age": 30}, {"name": "Bob", "age": 25}]
sorted_users = sorted(users, key=lambda u: u["age"])
```

---

## Common Pitfalls

### Pitfall 1: Comparing Different Types

```python
"10" == 10  # False (string vs. int)
```

Python does **not** coerce types for equality. If you want numeric comparison, convert explicitly:

```python
int("10") == 10  # True
```

### Pitfall 2: Using `==` Instead of `is` for None

```python
# Risky (custom __eq__ can override)
if value == None:
    process()

# Safe
if value is None:
    process()
```

### Pitfall 3: Floating-Point Equality

```python
0.1 + 0.2 == 0.3  # False (floating-point precision)
```

**Fix**: Use `math.isclose()` for approximate equality:

```python
import math
math.isclose(0.1 + 0.2, 0.3)  # True
```

### Pitfall 4: Identity with Small Integers

```python
a = 256
b = 256
print(a is b)  # True (cached)

x = 257
y = 257
print(x is y)  # False (not cached)
```

Python caches small integers (`-5` to `256`). Never rely on `is` for value comparison—use `==`.

---

## Quick Reference

| Operator | Meaning | Example | Method |
| :--- | :--- | :--- | :--- |
| `==` | Equal to | `a == b` | `__eq__` |
| `!=` | Not equal to | `a != b` | `__ne__` |
| `<` | Less than | `a < b` | `__lt__` |
| `<=` | Less than or equal | `a <= b` | `__le__` |
| `>` | Greater than | `a > b` | `__gt__` |
| `>=` | Greater than or equal | `a >= b` | `__ge__` |
| `is` | Identity (same object) | `a is b` | (built-in) |
| `is not` | Not identity | `a is not b` | (built-in) |

---

## A Coherent System

Comparison operators in Python are **polymorphic protocols**:

*   **Value vs. Identity**: `==` compares values; `is` compares object identity.
*   **Type-Aware**: Comparisons respect type semantics (numeric, lexicographic, element-wise).
*   **Extensible**: Custom classes define comparison behavior via special methods.
*   **Chainable**: Multiple comparisons can be combined naturally.

**The essence:** Comparison operators in Python distinguish between value equality and object identity. Understanding this distinction—and when to use `==` vs. `is`—is fundamental to writing correct Python code.
