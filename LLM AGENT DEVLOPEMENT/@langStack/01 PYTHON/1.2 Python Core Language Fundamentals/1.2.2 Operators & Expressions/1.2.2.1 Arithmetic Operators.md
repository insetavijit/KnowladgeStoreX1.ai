Arithmetic operators in Python are not merely symbols for calculation—they are **interfaces to object behavior**. Each operator invokes a specific method on the objects involved, and the result depends entirely on how those objects define their arithmetic protocol.

Understanding arithmetic operators requires recognizing that Python's numeric model is **object-oriented at its core**. When you write `a + b`, you're not performing primitive addition; you're calling `a.__add__(b)`, and the object `a` determines what that means.

---

## The Fundamental Principle: Operators Are Method Calls

Every arithmetic operator in Python maps to a **special method** (also called a "dunder method" for double underscore):

```python
a + b   # Calls a.__add__(b)
a - b   # Calls a.__sub__(b)
a * b   # Calls a.__mul__(b)
a / b   # Calls a.__truediv__(b)
```

This design enables **operator overloading**: custom classes can define what arithmetic means for their instances.

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)

v1 = Vector(1, 2)
v2 = Vector(3, 4)
v3 = v1 + v2  # Calls v1.__add__(v2)
print(v3.x, v3.y)  # 4, 6
```

The `+` operator doesn't "know" how to add vectors—the `Vector` class teaches it.

---

## Core Arithmetic Operators

### Addition: `+`

Adds two numbers or concatenates sequences.

```python
# Numeric addition
10 + 5      # 15
3.14 + 2.0  # 5.14

# String concatenation
"Hello" + " World"  # "Hello World"

# List concatenation
[1, 2] + [3, 4]  # [1, 2, 3, 4]
```

**Type promotion**: When mixing types, Python promotes to the "wider" type:

```python
10 + 3.5    # 13.5 (int promoted to float)
True + 5    # 6 (bool promoted to int)
```

### Subtraction: `-`

Subtracts the right operand from the left.

```python
10 - 3   # 7
5.5 - 2  # 3.5
```

**Unary negation**:

```python
-10   # -10
-(-5) # 5
```

### Multiplication: `*`

Multiplies two numbers or repeats sequences.

```python
# Numeric multiplication
5 * 3      # 15
2.5 * 4    # 10.0

# String repetition
"Ha" * 3   # "HaHaHa"

# List repetition
[0] * 5    # [0, 0, 0, 0, 0]
```

### Division: `/`

**Always returns a float**, even if both operands are integers.

```python
10 / 2   # 5.0 (not 5!)
7 / 2    # 3.5
```

This is a **Python 3 change**. In Python 2, `/` performed integer division for integers.

### Floor Division: `//`

Returns the **largest integer** less than or equal to the result.

```python
10 // 3   # 3 (not 3.333...)
7 // 2    # 3
-7 // 2   # -4 (rounds toward negative infinity)
```

**With floats**:

```python
10.0 // 3.0  # 3.0 (float result, but floor value)
```

### Modulo: `%`

Returns the **remainder** after division.

```python
10 % 3   # 1 (10 = 3*3 + 1)
7 % 2    # 1
```

**Sign follows divisor**:

```python
-7 % 3   # 2 (not -1)
7 % -3   # -2
```

This behavior ensures: `a == (a // b) * b + (a % b)`

### Exponentiation: `**`

Raises the left operand to the power of the right.

```python
2 ** 3    # 8 (2³)
10 ** 2   # 100
2 ** -1   # 0.5 (2⁻¹)
```

**Right-associative**:

```python
2 ** 3 ** 2  # 512 (2⁹, not 8²)
# Evaluated as: 2 ** (3 ** 2)
```

---

## Type Interactions

### Numeric Tower

Python's numeric types form a hierarchy:

```
bool → int → float → complex
```

Operations between different types promote to the wider type:

```python
True + 1       # 2 (bool → int)
10 + 3.5       # 13.5 (int → float)
5 + 2j         # (5+2j) (int → complex)
```

### Division Special Case

Division (`/`) **always returns float**, regardless of operand types:

```python
10 / 5   # 2.0 (not 2)
```

If you want integer division, use `//`:

```python
10 // 5  # 2
```

---

## Operator Precedence

Arithmetic operators follow mathematical precedence (PEMDAS):

| Precedence | Operator | Description |
| :--- | :--- | :--- |
| Highest | `**` | Exponentiation |
| | `-x`, `+x` | Unary negation, unary plus |
| | `*`, `/`, `//`, `%` | Multiplication, division, floor division, modulo |
| Lowest | `+`, `-` | Addition, subtraction |

**Examples**:

```python
2 + 3 * 4      # 14 (not 20)
2 ** 3 ** 2    # 512 (right-associative)
-2 ** 2        # -4 (not 4, unary minus has lower precedence)
(-2) ** 2      # 4
```

Use **parentheses** to override precedence:

```python
(2 + 3) * 4    # 20
```

---

## Augmented Assignment

Arithmetic operators can be combined with assignment:

```python
x = 10
x += 5   # x = x + 5 → 15
x -= 3   # x = x - 3 → 12
x *= 2   # x = x * 2 → 24
x /= 4   # x = x / 4 → 6.0
x //= 2  # x = x // 2 → 3.0
x %= 2   # x = x % 2 → 1.0
x **= 3  # x = x ** 3 → 1.0
```

**Important**: For immutable types (int, float, str), augmented assignment creates a new object:

```python
x = 10
id_before = id(x)
x += 5
id_after = id(x)
print(id_before == id_after)  # False (new object)
```

For mutable types (list), it modifies in-place:

```python
lst = [1, 2]
id_before = id(lst)
lst += [3]
id_after = id(lst)
print(id_before == id_after)  # True (same object)
```

---

## Common Patterns

### Pattern 1: Swap Without Temporary

```python
a, b = 10, 20
a, b = b, a  # Swap
print(a, b)  # 20, 10
```

### Pattern 2: Divmod (Division + Modulo)

```python
quotient, remainder = divmod(10, 3)
print(quotient, remainder)  # 3, 1
```

More efficient than computing separately:

```python
# Less efficient
q = 10 // 3
r = 10 % 3
```

### Pattern 3: Power of Two Check

```python
def is_power_of_two(n):
    return n > 0 and (n & (n - 1)) == 0

print(is_power_of_two(8))   # True
print(is_power_of_two(10))  # False
```

---

## Common Pitfalls

### Pitfall 1: Division Always Returns Float

```python
result = 10 / 5
print(type(result))  # <class 'float'> (not int!)
```

**Fix**: Use `//` for integer division:

```python
result = 10 // 5  # 2 (int)
```

### Pitfall 2: Floor Division with Negatives

```python
-7 // 2  # -4 (not -3!)
```

Floor division rounds **toward negative infinity**, not toward zero.

**Fix**: If you want truncation toward zero, use `int()`:

```python
int(-7 / 2)  # -3
```

### Pitfall 3: Exponentiation Precedence

```python
-2 ** 2  # -4 (not 4!)
```

Exponentiation has higher precedence than unary minus.

**Fix**: Use parentheses:

```python
(-2) ** 2  # 4
```

### Pitfall 4: Floating-Point Precision

```python
0.1 + 0.2  # 0.30000000000000004 (not exactly 0.3)
```

This is a fundamental limitation of binary floating-point arithmetic.

**Fix**: Use `decimal` for exact decimal arithmetic:

```python
from decimal import Decimal
Decimal('0.1') + Decimal('0.2')  # Decimal('0.3')
```

---

## Quick Reference

| Operator | Name | Example | Result | Special Method |
| :--- | :--- | :--- | :--- | :--- |
| `+` | Addition | `10 + 5` | `15` | `__add__` |
| `-` | Subtraction | `10 - 5` | `5` | `__sub__` |
| `*` | Multiplication | `10 * 5` | `50` | `__mul__` |
| `/` | Division | `10 / 5` | `2.0` | `__truediv__` |
| `//` | Floor Division | `10 // 3` | `3` | `__floordiv__` |
| `%` | Modulo | `10 % 3` | `1` | `__mod__` |
| `**` | Exponentiation | `2 ** 3` | `8` | `__pow__` |

---

## A Coherent System

Arithmetic operators in Python are **polymorphic interfaces**:

*   **Object-oriented**: Operators call methods (`__add__`, `__mul__`, etc.).
*   **Type-aware**: Results depend on operand types (promotion, coercion).
*   **Extensible**: Custom classes can define arithmetic behavior.
*   **Predictable**: Precedence follows mathematical conventions.

**The essence:** Arithmetic operators in Python are method calls that enable objects to define their own numeric behavior. Understanding this object-oriented foundation explains operator overloading, type promotion, and the flexibility of Python's numeric model.
