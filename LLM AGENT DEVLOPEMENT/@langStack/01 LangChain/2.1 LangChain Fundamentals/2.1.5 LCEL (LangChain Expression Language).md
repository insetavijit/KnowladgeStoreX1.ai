
| **Subtopic** | **Focus & Purpose** | **Key Concepts / Details** | **One-Line Recall** |
| :--- | :--- | :--- | :--- |
| **[[2.1.5 LCEL (LangChain Expression Language)]]** | Modern declarative chain syntax | `|` pipe operator, standard interface for all generic components | A declarative way to easily compose chains together. |
| **[[Pipe Operator]]** | Chaining components elegantly | unix-style piping `|`, feeding output of one runnable to next | The `|` symbol feeds the output of one component into the next. |
| **[[Runnable Interface]]** | Standard protocol for LangChain objects | `invoke`, `batch`, `stream`, `ainvoke`, standardized methods | The common interface (invoke/stream/batch) all LCEL objects share. |
| **[[RunnablePassthrough]]** | Passing inputs unchanged or adding keys | passing data to multiple steps, adding extra arguments to chains | Allows inputs to pass through a step unchanged or with additions. |
| **[[RunnableLambda]]** | Turning functions into chain steps | wrapping custom python functions to be usable in LCEL chains | Converts any Python function into a Runnable LCEL component. |
| **[[RunnableBranch]]** | Conditional logic in chains | routing inputs to different chains based on conditions, if/else | Adds conditional routing logic (if/else) to chains. |
| **[[LCEL vs Legacy Chains]]** | Transitioning to modern LangChain | visibility, streaming support, ease of customization, async native | LCEL is the modern, standard, production-ready way to build chains. |
