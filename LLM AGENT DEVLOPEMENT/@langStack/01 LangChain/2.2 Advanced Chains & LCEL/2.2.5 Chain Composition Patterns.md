
| **Subtopic** | **Focus & Purpose** | **Key Concepts / Details** | **One-Line Recall** |
| :--- | :--- | :--- | :--- |
| **[[2.2.5 Chain Composition Patterns]]** | Architecting complex systems | modular design, single responsibility principle, nested chains | Best practices for building large apps out of small chains. |
| **[[Nested Chains]]** | Encapsulation | sub-chains within parent chains, isolating complexity | Putting a chain inside another chain to hide details. |
| **[[Interface Design]]** | Clear contracts | defining strict inputs/outputs between components, schemas | Agreeing on what data looks like between different parts of the system. |
| **[[Input/Output Mapping]]** | Connecting disparate parts | `RunnablePassthrough.assign()`, renaming keys, data transformation adapters | altering data shape so two incompatible chains can connect. |
| **[[Chain Reuse]]** | Reducing boilerplate | creating factory functions for chains, shared prompt/model configs | Writing a chain once and using it in many places. |
| **[[Composition Strategies]]** | Architectural patterns | router pattern, map-reduce, refined-query, iterative refinement | Standard blueprints for solving common LLM problems. |
| **[[Maintainable Chains]]** | Long-term code health | readability, self-documenting steps, avoiding "spaghetti chains" | Writing chains that are easy to understand and fix later. |
