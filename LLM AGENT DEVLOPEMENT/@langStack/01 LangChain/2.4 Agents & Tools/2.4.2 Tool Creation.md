
| **Subtopic** | **Focus & Purpose** | **Key Concepts / Details** | **One-Line Recall** |
| :--- | :--- | :--- | :--- |
| **[[2.4.2 Tool Creation]]** | Building custom tools | `@tool` decorator, defining schemas, connecting python functions | Making your own functions callable by the LLM. |
| **[[@tool Decorator]]** | Simple definition | standard python docstrings as tool descriptions, type hints | The easiest way to turn a function into a LangChain tool. |
| **[[StructuredTool]]** | Complex inputs | defining sophisticated input schemas with Pydantic | Creating tools that take complex objects as arguments. |
| **[[Input Schemas]]** | Data validation | ensuring the LLM sends the right data types | JSON Schema definitions that tell the LLM what inputs are valid. |
| **[[Error Handling]]** | Robustness | `handle_tool_error`, returning meaningful error messages to agent | Telling the agent "that didn't work, try again" instead of crashing. |
| **[[Tool Descriptions]]** | The "UI" for the LLM | writing clear, precise descriptions so the LLM knows when to use it | The documentation that the LLM reads to understand the tool. |
| **[[Async Tools]]** | Performance | defining `_arun` for non-blocking execution | Tools that can run in the background without freezing the agent. |
