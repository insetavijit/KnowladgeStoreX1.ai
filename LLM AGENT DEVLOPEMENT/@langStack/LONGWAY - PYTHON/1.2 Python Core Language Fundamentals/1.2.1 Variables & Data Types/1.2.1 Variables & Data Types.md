This chapter establishes the **fundamental data model of Python** by explaining how values are stored, named, and interpreted at runtime. You learn that variables are **name bindings to objects**, not fixed containers, and that Python uses **dynamic typing with runtime type inference**.

It introduces Python’s **core primitive types** (`int`, `float`, `str`, `bool`) along with `None` as an explicit representation of “no value.” The chapter emphasizes **professional coding standards**, including **PEP 8 naming conventions**, the use of **constants by convention**, and **type hints (PEP 484)** to improve code clarity and static analysis without enforcing types.

Finally, it covers **type conversion and inspection**, teaching how to safely convert between compatible types and verify types at runtime using `type()` and `isinstance()`. By the end, you can write **clean, readable, and predictable Python code** that clearly communicates intent and behaves correctly at runtime.


| **Subtopic**                       | **Focus & Purpose**                                      | **Key Concepts / Details**                                                 | **One-Line Recall**                                      |
| ---------------------------------- | -------------------------------------------------------- | -------------------------------------------------------------------------- | -------------------------------------------------------- |
| **[[Variable Declaration]]**       | Understand how variables are created and bound in Python | name binding, assignment operator `=`, reassignment                        | Variables are labels bound to objects, not containers.   |
| **[[Naming Conventions (PEP 8)]]** | Write readable, professional Python code                 | `snake_case`, descriptive names, avoid keywords, constants in `UPPER_CASE` | PEP 8 defines how variables should be named for clarity. |
| **[[Primitive Data Types]]**       | Learn Python’s core built-in value types                 | `int`, `float`, `str`, `bool`                                              | Core types represent numbers, text, and truth values.    |
| **[[Dynamic Typing]]**             | Understand Python’s runtime type system                  | no explicit type declaration, type changes at runtime                      | Python determines types at runtime, not compile time.    |
| **[[Type Inference]]**             | Recognize how Python infers types automatically          | inferred from assigned value                                               | Python infers variable type from the assigned object.    |
| **[[Type Hints (PEP 484)]]**       | Improve readability and static analysis                  | `x: int`, `-> str`, optional typing                                        | Type hints describe intent without enforcing types.      |
| **[[Type Conversion (Casting)]]**  | Convert values between compatible types                  | `int()`, `float()`, `str()`, `bool()`                                      | Casting converts values between compatible types.        |
| **[[NoneType]]**                   | Represent absence of a value                             | `None`, null-like semantics, identity vs equality                          | `None` represents “no value” in Python.                  |
| **[[Constants]]**                  | Communicate immutability by convention                   | uppercase naming, no language-level enforcement                            | Constants are a convention, not a restriction.           |
| **[[Type Checking & Inspection]]** | Inspect and validate variable types                      | `type()`, `isinstance()`                                                   | Use `isinstance()` for safe runtime type checks.         |
