# 1.12.2 Prompt Management Systems

| **Section** | **Focus** | **Key Utilities / Concepts** | **One-Line Recall** |
| :--- | :--- | :--- | :--- |
| **[[1.12.2.1 Centralized Libraries]]** | Organization | "The Prompt Store", single source of truth | Avoiding the "prompts hardcoded in random Python files" antipattern. |
| **[[1.12.2.2 Template Engines (Jinja2)]]** | Dynamic text | Variable substitution `{{ user_name }}`, logic | Using standard templating languages to inject data into prompts. |
| **[[1.12.2.3 CMS for Prompts]]** | UI | Non-technical editing, WYSIWYG | allowing Product Managers to edit prompts without needing to write code. |
| **[[1.12.2.4 Role-Based Access]]** | Security | "Who can edit system prompts?", permissioning | Locking down critical prompts so interns can't accidentally break the app. |
| **[[1.12.2.5 Environment Variables]]** | Config | Dev vs Staging vs Prod prompts | Using different prompts for different environments (e.g., debug mode in Dev). |
| **[[1.12.2.6 Dynamic Injection]]** | Runtime | Inserting context at query time | Taking the user's current data and injecting it into the prompt template. |
| **[[1.12.2.7 Search & Discovery]]** | Reuse | Tags, categories, "Has anyone written a SQL prompt?" | Finding existing prompts prevents duplication of work. |
| **[[1.12.2.8 Dependency Management]]** | Graph | Sub-prompts, partials, imports | Managing prompts that include other prompts (like header/footer partials). |
| **[[1.12.2.9 UI Editors]]** | Experience | Playground integration, testing in browser | Editing a prompt and immediately hitting "Run" to see the output. |
| **[[1.12.2.10 Synchronization]]** | Deployment | Syncing DB to API, caching | Ensuring the application always has the latest version of the prompts from the CMS. |

This table represents a **complete guide to Prompt Management Systems**, the CMS for AI.
