# 1.13.1 Prompt Chaining

| **Section** | **Focus** | **Key Utilities / Concepts** | **One-Line Recall** |
| :--- | :--- | :--- | :--- |
| **[[1.13.1.1 Sequential Pipelines]]** | Structure | A -> B -> C, Linear chains | Passing the output of Prompt A as the input to Prompt B. |
| **[[1.13.1.2 Parallel Execution]]** | Efficiency | Map-Reduce, concurrent calls | Running 5 prompts at once and then summarizing their results. |
| **[[1.13.1.3 Conditional Branching]]** | Logic | "If A, run Prompt B; else run Prompt C" | Adding boolean logic to the chain to handle different user intents. |
| **[[1.13.1.4 Map-Reduce Pattern]]** | Summarization | "Summarize each chapter (Map), then summarize the summaries (Reduce)" | Analyzing documents larger than the context window by breaking them down. |
| **[[1.13.1.5 State Passing]]** | Memory | Variables, scratchpad, context dict | Carrying information (variables) from step 1 through to step 10. |
| **[[1.13.1.6 Loop Structures]]** | Iteration | "Repeat until X happens", `while` loops | Retrying a prompt until it passes a validation check (e.g., valid JSON). |
| **[[1.13.1.7 Human-in-the-Loop Chains]]** | Verification | "Ask user for approval before step 5" | Pausing the chain to get human input or confirmation. |
| **[[1.13.1.8 Frameworks (LangChain)]]** | Tooling | `LLMChain`, `SequentialChain`, graph definitions | Libraries that standardize the code for linking prompts together. |
| **[[1.13.1.9 Debugging Chains]]** | Observability | Tracing, intermediate outputs, "Where did it break?" | Seeing the output of step 3 is crucial to understanding why step 4 failed. |
| **[[1.13.1.10 Prompt Composition]]** | Modularity | Reusing "Check Toxicity" chain across multiple apps | treating chains as reusable functions/modules. |

This table represents a **complete guide to Prompt Chaining**, programming with prompts.
