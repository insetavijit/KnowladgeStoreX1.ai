# 1.6.1 Problem Decomposition

| **Section** | **Focus** | **Key Utilities / Concepts** | **One-Line Recall** |
| :--- | :--- | :--- | :--- |
| **[[1.6.1.1 Recursive Breakdown]]** | Simplification | Splitting big problems into smaller ones, recursion | If a problem is too hard, split it into two easier problems. Repeat until trivial. |
| **[[1.6.1.2 Dependency Mapping]]** | Order of operations | DAG (Directed Acyclic Graph), prerequisites, blocking steps | Identifying which sub-tasks *must* happen before others prevents logical deadlocks. |
| **[[1.6.1.3 Sub-Goal Identification]]** | Milestones | Key Results, intermediate states, checkpoints | Defining clear intermediate goals helps the model track progress towards the final solution. |
| **[[1.6.1.4 Divide and Conquer]]** | Algorithm design | Parallel processing, isolation, localized solving | Solving each piece in isolation minimizes complexity and context pollution. |
| **[[1.6.1.5 Modular Solving]]** | Encapsulation | Functions, independent units, loose coupling | Treating each sub-problem as a black box function makes the overall solution more robust. |
| **[[1.6.1.6 Interface Definitions]]** | Integration | Inputs/Outputs between steps, contract definition | Clearly defining *how* the output of Step A becomes the input of Step B is the glue of decomposition. |
| **[[1.6.1.7 Sequencing Steps]]** | Workflow | Linear planning, Gantt chart logic, execution order | Arranging the decomposed parts into a coherent, logical narrative or plan. |
| **[[1.6.1.8 Identifying Bottlenecks]]** | Optimization | Critical path analysis, hardest part first | Solving the riskiest or most difficult sub-problem first prevents late-stage failure. |
| **[[1.6.1.9 Synthesis of Parts]]** | Reassembly | Aggregation, combining answers, holism | The final step is always putting the Humpty Dumpty of independent answers back together. |
| **[[1.6.1.10 Decomposition Verification]]** | Quality check | "Does the sum equal the whole?", completeness check | Verifying that the decomposed sub-problems actually cover the entire scope of the original request. |

This table represents a **complete guide to Problem Decomposition**, the first step in solving anything complex.
