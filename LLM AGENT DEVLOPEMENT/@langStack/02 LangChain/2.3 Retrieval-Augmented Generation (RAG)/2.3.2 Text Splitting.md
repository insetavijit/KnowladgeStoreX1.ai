
| **Subtopic** | **Focus & Purpose** | **Key Concepts / Details** | **One-Line Recall** |
| :--- | :--- | :--- | :--- |
| **[[2.3.2 Text Splitting]]** | Preparing text for embedding | dividing long docs into smaller chunks, `TextSplitter` base class | Breaking big documents into small, digestible pieces. |
| **[[RecursiveCharacterTextSplitter]]** | The standard splitter | splitting by specific separators recursively, keeping context | The default, best-practice way to split text naturally. |
| **[[Chunk Size/Overlap]]** | Controlling context window | `chunk_size` (tokens/chars), `chunk_overlap` (sliding window) | Determining how big pieces are and how much they repeat. |
| **[[Semantic Splitting]]** | Meaning-based chunking | splitting based on embedding similarity, not just characters | Grouping text by meaning rather than just paragraph breaks. |
| **[[Context Preservation]]** | Keeping related info together | ensuring headers stay with content, adding metadata to chunks | Making sure chunks still make sense when taken out of context. |
| **[[Splitting Strategies]]** | Code vs Text | `PythonCodeTextSplitter`, `MarkdownHeaderTextSplitter` | specialized rules for splitting code or structured docs. |
| **[[Optimal Chunking]]** | Performance tuning | balancing retrieval precision vs generation context | Finding the "Goldilocks" size for your data. |
