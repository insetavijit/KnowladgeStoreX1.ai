
| **Subtopic** | **Focus & Purpose** | **Key Concepts / Details** | **One-Line Recall** |
| :--- | :--- | :--- | :--- |
| **[[2.2.4 Custom Runnables]]** | Extending LangChain functionality | `@chain` decorator, `RunnableLambda`, subclassing `RunnableSerializable` | Making your own code work exactly like standard LangChain components. |
| **[[Runnable Method Implementation]]** | Standardizing access | implementing `invoke`, `batch`, `stream` methods correctly | Ensuring your custom class has the standard API. |
| **[[Type Annotations]]** | Improving developer experience | `InputType`, `OutputType` definitions, Pydantic validation | Adding type safety so your custom components are easy to use. |
| **[[Composition]]** | Mixing custom and standard | using custom runnables in pipes `|`, combining with off-the-shelf parts | Plugging your custom logic into standard chains. |
| **[[Reusable Components]]** | Modular architecture | packaging common logic as runnables, sharing across projects | wrapping repeated logic into a standard, portable box. |
| **[[RunnableConfig]]** | Passing runtime parameters | accessing `callbacks`, `recursion_limit` in custom logic | allowing your custom component to be configured at runtime. |
| **[[Async Support]]** | Performance in custom code | implementing `ainvoke`, `astream`, `abatch` for non-blocking execution | Ensuring your component doesn't slow down the whole async app. |
