## 1.1 LLM Agents — Autonomous systems where LLMs reason and act toward goals

LLM Agents use large language models as the central reasoning engine within a control loop that enables proactive pursuit of objectives. They integrate tools, memory, and iterative processes to handle complex, multi-step tasks far beyond simple chat responses.

### 1.1.1 What are LLM Agents — Defines the paradigm and why agents differ from chatbots

#### Definition & core idea — LLM as controller in a sense–think–act loop
The agent paradigm positions the LLM as an intelligent controller orchestrating perception, reasoning, and action in a continuous cycle.

- **LLM as brain** — makes decisions, not just text: Transforms generative capabilities into decision-making.
- **Agent formula** — LLM + tools + memory + loop: Essential components for autonomy.
- **Sense → Think → Act** — continuous control cycle: Ongoing adaptation to environment and feedback.

#### Agent vs Chatbot — Reactive replies vs proactive goal pursuit
Agents are fundamentally proactive and stateful, while chatbots remain reactive and stateless.

- **Reactive vs proactive** — waits vs initiates: Agents drive progress toward goals.
- **Stateless vs stateful** — no memory vs persistent context: Enables long-term coherence.
- **Text-only vs tool-using** — generate vs act: Real-world impact through external interfaces.
- **Single vs multi-step** — one-shot vs iterative: Handles complexity over multiple cycles.

#### Autonomy & goals — Self-directed behavior toward objectives
Agents operate with high autonomy once given an objective.

- **Self-initiation** — decides next step: No constant prompting required.
- **Explicit goals** — works toward outcomes: Clear success criteria.
- **Termination** — stops on success/failure: Built-in exit conditions.
- **Minimal supervision** — human sets intent only: Scalable delegation.

#### Core capabilities — Abilities enabling multi-step action
Agents combine multiple competencies for robust performance.

- **Reasoning** — understand & decompose problems: Breaks down ambiguous queries.
- **Planning** — order steps: Sequences actions effectively.
- **Tool use** — APIs, code, search: Extends capabilities beyond language.
- **Memory** — retain context & facts: Short- and long-term persistence.
- **Reflection** — evaluate & adjust: Self-correction and improvement.

#### ReAct pattern — Reasoning interleaved with actions
Foundational paradigm introduced by Yao et al. (2022) that remains widely used.

- **Reason → Act → Observe** — think, do, see loop: Transparent and adaptive.
- **Transparency** — interpretable decisions: Thoughts logged for debugging.
- **Adaptivity** — adjusts from feedback: Handles unexpected outcomes.

#### When to use agents — Scenarios needing autonomy
Best applied when tasks require iteration and external interaction.

- **Multi-step tasks** — more than one decision: Complex problem-solving.
- **Tool interaction** — external systems: APIs, browsers, code execution.
- **Stateful workflows** — context over time: Ongoing processes.
- **Dynamic decisions** — path not known upfront: Uncertain environments.

#### Agents vs simple LLM calls — When agents are overkill
For straightforward tasks, direct prompting is more efficient.

- **One-shot generation** — single response: Text completion or Q&A.
- **Stateless problems** — no memory needed: Isolated queries.
- **Low latency/cost** — minimal overhead: High-volume simple calls.

#### Agent vs workflow vs pipeline — Control strategies compared
Different levels of flexibility in execution control.

- **Pipeline** — fixed linear steps: Predictable but rigid.
- **Workflow** — predefined branches: Some adaptability.
- **Agent** — LLM decides dynamically: Maximum flexibility.

#### Paradigm shift — From chat to action systems
Represents a fundamental evolution in LLM application.

- **Prompt → loop** — iterative control: From single calls to sustained processes.
- **LLM as controller** — orchestrates tools & memory: Central decision hub.
- **Text to action** — systems that do: Real-world agency.

### 1.1.2 Agent Architecture Components — Internal structure of an agent

Modern agents follow modular architectures with clear separation of concerns.

#### Perception — Processes user and tool inputs
Initial stage for understanding the environment.

- **Intent extraction** — understand requests: Parses goals from natural language.
- **Context parsing** — usable state: Formats inputs for LLM consumption.

#### Memory — Stores state across steps/sessions
Critical for coherence over time.

- **Short-term** — current context: In-loop working memory.
- **Long-term** — facts/history: Vector stores or databases.
- **Working** — task scratchpad: Temporary reasoning space.

#### Planning — Decides what to do next
Strategic component for goal achievement.

- **Task decomposition** — split goals: Hierarchical breakdown.
- **Step sequencing** — order actions: Dependency-aware ordering.

#### Action — Executes decisions
Interface to the external world.

- **Tool calls** — APIs/services: Structured function execution.
- **Code/DB ops** — compute & data: Direct environment manipulation.

#### Reflection — Learns from outcomes
Enables self-improvement within runs.

- **Evaluate results** — did it work?: Success measurement.
- **Error detection** — what failed?: Failure analysis.
- **Strategy update** — improve next step: Adaptive planning.

#### Agent loop — Control cycle
Core execution pattern.

- **Perceive → Plan → Act → Observe → Reflect → Update → Repeat**: Full autonomous cycle.

#### Stateful vs stateless — Memory design trade-offs
Design choice impacting cost and capability.

- **Stateless** — cheaper, simpler: Suitable for simple tasks.
- **Stateful** — richer, persistent: Required for complex workflows.

#### Control flow patterns — Execution styles
Various supported structures.

- **Sequential, conditional, iterative, parallel, hierarchical**: Flexible orchestration options.

### 1.1.3 Agent Types & Categories — Taxonomy of agent behaviors

Agents vary by primary pattern and domain focus.

- **Conversational agents** — Dialogue-focused assistants.
- **Function-calling agents** — Structured API execution.
- **ReAct agents** — Reasoning + acting loops.
- **Reflection agents** — Self-critique & refinement.
- **Tool-using agents** — Heavy external interaction.
- **Planning agents** — Upfront task breakdown.
- **Research agents** — Search & synthesize info.
- **Coding agents** — Write, run, debug code.
- **Hybrid agents** — Combine multiple patterns.
- **Match to use case** — Choose type by task needs.

### 1.1.4 Prompt Engineering for Agents — Controlling agent behavior with prompts

Prompt design remains crucial for reliable agent performance.

- **Role & persona** — Who the agent is: Defines identity and expertise.
- **Instruction clarity** — What to do and how: Explicit guidelines.
- **System prompts** — Global rules: Consistent behavior enforcement.
- **Few-shot examples** — Demonstrate behavior: Pattern matching.
- **Chain-of-thought** — Guide reasoning: Step-by-step thinking.
- **Guardrails** — Safety and limits: Prevent undesirable actions.
- **Context formatting** — Structured memory/input: JSON/XML organization.
- **Persona engineering** — Tone & expertise: Domain adaptation.
- **Prompt iteration** — Test, refine, improve: Empirical optimization.

### 1.1.5 Tool Use & Advanced Orchestration — Making agents act robustly

Reliable tool integration is essential for practical agents.

- **Function calling** — Structured tool invocation: Standardized interfaces.
- **Tool schemas** — Define inputs/outputs: Clear contracts.
- **Tool selection logic** — Choose by context: LLM-driven decisions.
- **Result composition** — Chain tool outputs: Build complex responses.
- **Feedback & recovery** — Retry, fallback, ask user: Error handling.
- **Dynamic tool use** — Adapt at runtime: Flexible capability.
- **Result validation** — Ensure correctness & safety: Output checks.
- **MCP** — Standard tool/context interface: Emerging interoperability.
- **Tools vs RAG vs fine-tuning** — Actions vs knowledge vs behavior: Complementary approaches.
- **Robust design** — Reliability, safety, cost control: Production considerations.

If you want, Boss, I can also generate:
- a **collapsed mini list** (only top 2 levels), or
- a version with **Obsidian wiki links** like `[[1.1.1 What are LLM Agents]]` for navigation.